<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>单元测试 | zhz blogs</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">单元测试</h1><a id="logo" href="/.">zhz blogs</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">单元测试</h1><div class="post-meta">Jul 21, 2017<span> | </span><span class="category"><a href="/categories/ios平台/">ios平台</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h1 id="单元测试和集成测试"><a href="#单元测试和集成测试" class="headerlink" title="单元测试和集成测试"></a>单元测试和集成测试</h1><p><code>Unit</code>: 单元测试，保证每一个类能够正常工作<br><code>UI</code>:   UI测试，也叫做集成测试，从业务层的角度保证各个业务可以正常工作。</p>
<h1 id="0-单元测试"><a href="#0-单元测试" class="headerlink" title="0. 单元测试 "></a><font color="red">0. 单元测试 </font></h1><p>准则:<br>保持测试的单一性<br>无耦合</p>
<p>概念: </p>
<blockquote>
<p>在计算机编程中，单元测试（英语：<code>Unit Testing</code>）又称为模块测试, 是针对程序模块的最小单位来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。 – 维基百科</p>
</blockquote>
<p>优点:</p>
<blockquote>
<p>避免低级错误<br>减少调试时间<br>增加可维护性<br>方便重构代码</p>
</blockquote>
<p>缺点:</p>
<blockquote>
<p>开发和维护成本高。<br>不能完全替代人工测试。</p>
</blockquote>
<p>单元测试适合范围:</p>
<blockquote>
<p>业务变动不频繁<br>业务属于核心功能</p>
</blockquote>
<h1 id="1-XCTest"><a href="#1-XCTest" class="headerlink" title="1. XCTest "></a><font color="red">1. XCTest </font></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">- (void)setUp &#123;</div><div class="line">    [super setUp];</div><div class="line">    //初始化的代码，在测试方法调用之前调用</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)tearDown &#123;</div><div class="line">    // 释放测试用例的资源代码，这个方法会每个测试用例执行后调用</div><div class="line">    // 如测试踢人接口后，需要在结束时将对应成员拉回群里，以保证下次的单元测试能够正常进行。</div><div class="line">    [super tearDown];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 判断这个类是否存在</div><div class="line">- (void)testStackExist &#123;</div><div class="line">    XCTAssertNotNil([TestStack class], @&quot;不存在&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 判断这类是否能创建</div><div class="line">- (void)testStackCanCreate &#123;</div><div class="line">    TestStack *stack = [TestStack new];</div><div class="line">    XCTAssertNotNil(stack, @&quot;不能创建&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)testPushANumberAndGetIt &#123;</div><div class="line">    TestStack *stack = [TestStack new];</div><div class="line">    [stack push:2.0];</div><div class="line">    double topN = [stack pop];</div><div class="line">    XCTAssertEqual(topN, 2.0, @&quot;怎么不相等呢&quot;);</div><div class="line">    </div><div class="line">//    [stack push:6.0];</div><div class="line">//    double topN2 = [stack pop];</div><div class="line">//    XCTAssertEqual(topN2, 2.0, @&quot;怎么不相等呢&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)testPerformanceExample &#123;</div><div class="line">    // 测试性能例子</div><div class="line">    [self measureBlock:^&#123;</div><div class="line">        // 需要测试性能的代码</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>常用断言</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">XCTFail</span>(format…) 生成一个失败的测试；</div><div class="line"></div><div class="line"><span class="built_in">XCTAssertNil</span>(arg1, format...) 为空判断，arg1为空时通过，反之不通过；</div><div class="line"></div><div class="line"><span class="built_in">XCTAssertNotNil</span>(arg1, format…) 不为空判断，arg1不为空时通过，反之不通过；</div><div class="line"></div><div class="line"><span class="built_in">XCTAssert</span>(expression, format...) 当expression求值为<span class="literal">TRUE</span>时通过；</div><div class="line"></div><div class="line"><span class="built_in">XCTAssertTrue</span>(expression, format...) 当expression求值为<span class="literal">TRUE</span>时通过；</div><div class="line"></div><div class="line"><span class="built_in">XCTAssertFalse</span>(expression, format...) 当expression求值为False时通过；</div><div class="line"></div><div class="line"><span class="built_in">XCTAssertEqualObjects</span>(arg1, arg2, format...) 判断相等，[arg1 isEqual: arg2] 值为True时通过，其中一个不为空时，不通过；</div><div class="line"></div><div class="line"><span class="built_in">XCTAssertNotEqualObjects</span>(arg1, arg2, format...) 判断不等，[arg1 isEqual: arg2]值为False时通过，</div><div class="line"></div><div class="line"><span class="built_in">XCTAssertEqual</span>(arg1, arg2, format...) 判断相等（当arg1和arg2是 C语言标量、结构体或联合体时使用,实际测试发现<span class="built_in">NSString</span>也可以）；</div><div class="line"></div><div class="line"><span class="built_in">XCTAssertNotEqual</span>(arg1, arg2, format...) 判断不等（当arg1和arg2是 C语言标量、结构体或联合体时使用）；</div><div class="line"></div><div class="line"><span class="built_in">XCTAssertEqualWithAccuracy</span>(arg1, arg2, accuracy, format...) 判断相等，（<span class="keyword">double</span>或<span class="keyword">float</span>类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；</div><div class="line"></div><div class="line"><span class="built_in">XCTAssertNotEqualWithAccuracy</span>(arg1, arg2, accuracy, format...) 判断不等，（<span class="keyword">double</span>或<span class="keyword">float</span>类型）提供一个误差范围，当在误差范围以内不等时通过测试；</div><div class="line"></div><div class="line"><span class="built_in">XCTAssertThrows</span>(expression, format...) 异常测试，当expression发生异常时通过；反之不通过；（很变态）</div><div class="line"></div><div class="line"><span class="built_in">XCTAssertThrowsSpecific</span>(expression, specificException, format...) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；</div><div class="line"></div><div class="line"><span class="built_in">XCTAssertThrowsSpecificNamed</span>(expression, specificException, exception_name, format...) 异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；</div><div class="line"></div><div class="line"><span class="built_in">XCTAssertNoThrow</span>(expression, format...) 异常测试，当expression没有发生异常时通过测试；</div><div class="line"></div><div class="line"><span class="built_in">XCTAssertNoThrowSpecific</span>(expression, specificException, format...) 异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；</div><div class="line"></div><div class="line"><span class="built_in">XCTAssertNoThrowSpecificNamed</span>(expression, specificException, exception_name, format...) 异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过</div></pre></td></tr></table></figure>
<h1 id="2-第三方测试框架"><a href="#2-第三方测试框架" class="headerlink" title="2. 第三方测试框架 "></a><font color="red">2. 第三方测试框架 </font></h1><ul>
<li><a href="https://github.com/erikdoe/ocmock.git" target="_blank" rel="external">OCMock</a></li>
<li><a href="https://github.com/kiwi-bdd/Kiwi.git" target="_blank" rel="external">Kiwi  老牌测试框架</a></li>
<li><a href="https://github.com/specta/specta.git" target="_blank" rel="external">specta </a></li>
<li><a href="https://github.com/Quick/Quick.git" target="_blank" rel="external">Quick 支持swift </a></li>
</ul>
<p>mock 表示一个模拟对象, 它是对现有类的行为一种模拟（或是对现有接口实现的模拟）<br>stub 追踪方法的调用，在方法调用的时候返回指定的值。<br>mock 与 stub 最大的区别在于 stub 只是简单的方法替换，而不涉及新的对象，被 stub 的对象可以是业务代码中真正的对象。而 mock 行为本身产生新的（不可能在业务代码中出现的）对象，并遵循类的定义相应某些方法。</p>
<h1 id="3-Kiwi"><a href="#3-Kiwi" class="headerlink" title="3. Kiwi "></a><font color="red">3. Kiwi </font></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#import &lt;Kiwi/Kiwi.h&gt;</div><div class="line">#import &quot;YppNetworkService.h&quot;</div><div class="line"></div><div class="line">SPEC_BEGIN(YppNetworkServiceSpec)</div><div class="line"></div><div class="line">describe(@&quot;YppNetworkService&quot;, ^&#123;</div><div class="line">    </div><div class="line">    context(@&quot;提审 环境测试: &quot;, ^&#123;</div><div class="line">        it(@&quot;APP_STORE 应该 等于 1 &quot;, ^&#123;</div><div class="line">            [[theValue(APP_STORE) should] equal:theValue(1)];</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        it(@&quot;ApiVersion 应该 等于 61 &quot;, ^&#123;</div><div class="line">            [[kApiVersion should] equal:@&quot;61&quot;];</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        it(@&quot;app version  应该 等于 3.3.9 &quot;, ^&#123;</div><div class="line">            NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];</div><div class="line">            NSString *app_Version = [infoDictionary objectForKey:@&quot;CFBundleShortVersionString&quot;];</div><div class="line">            [[app_Version should] equal:@&quot;3.5.1&quot;];</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">&#125;);</div><div class="line"></div><div class="line">SPEC_END</div></pre></td></tr></table></figure>
<p><code>describe</code> : 行为描述（Specs）, 描述需要测试的对象内容<br><code>context</code> : 描述测试上下文<br><code>it</code> 中的是测试的本体，描述了这个测试应该满足的条件, 实际的测试写在it里，是由一个一个的期望(Expectations)来进行描述的，期望相当于传统测试中的断言，要是运行的结果不能匹配期望，则测试失败</p>
<p>it有两个参数:</p>
<pre><code>* 行为描述
* 行为的测试代码
</code></pre><p>三者共同构成了Kiwi测试中的行为描述。</p>
<p>其他关键词:</p>
<ul>
<li><code>beforeAll(aBlock)</code> - 当前scope内部的所有的其他block运行之前调用一次</li>
<li><code>afterAll(aBlock)</code> - 当前scope内部的所有的其他block运行之后调用一次</li>
<li><code>beforeEach(aBlock)</code> - 在scope内的每个it之前调用一次，对于context的配置代码应该写在这里</li>
<li><code>afterEach(aBlock)</code> - 在scope内的每个it之后调用一次，用于清理测试后的代码</li>
<li><code>specify(aBlock)</code> - 可以在里面直接书写不需要描述的测试</li>
<li><code>pending(aString, aBlock)</code> - 只打印一条log信息，不做测试。这个语句会给出一条警告，可以作为一开始集中书写行为描述时还未实现的测试的提示。</li>
<li><code>xit(aString, aBlock)</code> - 和pending一样，另一种写法。因为在真正实现时测试时只需要将x删掉就是it，但是pending语意更明确，因此还是推荐pending</li>
<li>由于有context的存在，以及其可以嵌套的特性，测试的流程控制相比传统测试可以更加精确。我们更容易把before和after的作用区域限制在合适的地方。</li>
</ul>
<p>在Kiwi中期望都由<code>should</code>或者<code>shouldNot</code>开头，并紧接一个或多个判断的的链式调用，大部分常见的是be或者haveSomeCondition的形式</p>
<p>注意:</p>
<ol>
<li>对于 Kiwi 的 stub，需要注意的是它不是永久有效的，在每个 it block 的结尾 stub 都会被清空，超出范围的方法调用将不会被 stub 截取到。</li>
<li></li>
</ol>
<h1 id="4-让你的代码更容易单元测试"><a href="#4-让你的代码更容易单元测试" class="headerlink" title="4. 让你的代码更容易单元测试 "></a><font color="red">4. 让你的代码更容易单元测试 </font></h1><blockquote>
<p>测试的准确性和工作量很大程度上依赖于开发人员的代码质量。</p>
<p>通常，为了单元测试的准确性，我们在写函数(方法)的时候会借鉴一些函数式编程的思想。其中最重要的一个思想就是 —- pure function(纯函数)</p>
</blockquote>
<p>何为Pure function？ 就是如果一个函数的输入一样，那么输出一定一样。</p>
<p>比如，这样的一个函数就不是pure function。因为它依赖于外部变量value的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static NSInteger value = 0;</div><div class="line"></div><div class="line">- (NSInteger)function_1&#123;</div><div class="line">    value = value + 1;</div><div class="line">    return value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而这个函数就是pure function，因为给定输入，输出一定一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (NSInteger)function:(NSInteger)value&#123;</div><div class="line">    value = value + 1;</div><div class="line">    return value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你写了一个没有参数，或者没有返回值的方法，那么你要小心了，很可能这个方法很难测试。</p>
<h1 id="5-code-coverage-测试覆盖率"><a href="#5-code-coverage-测试覆盖率" class="headerlink" title="5. code coverage 测试覆盖率"></a>5. code coverage 测试覆盖率</h1><pre><code>report -&gt; by group -&gt; coverage
</code></pre><h1 id="6-概念"><a href="#6-概念" class="headerlink" title="6. 概念"></a>6. 概念</h1><p><code>TDD(Test Driven Development)</code> - 测试驱动开发 是保证代码质量的不二法则, 是敏捷开发中的一项核心实践和技术，也是一种设计方法论。TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。TDD虽是敏捷方法的核心实践，但不只适用于XP（Extreme Programming），同样可以适用于其他开发方法和过程。<br>TDD的基本思路就是通过测试来推动整个开发的进行，但测试驱动开发并不只是单纯的测试工作，而是把需求分析，设计，质量控制量化的过程。</p>
<p><code>BDD(Behavior-driven development)</code> - 行为驱动开发。行为驱动开发简单来说就是先定义行为，然后定义测试用例，接着再编写代码。 实践中发现，通常没有那么多时间来先定义行为，不过BDD中的domain-specific language (DSL)能够很好的描述用例的行为。<br>BDD的框架让测试用例的目的更加明确，测试是否通过更加清晰<br>BDD的核心是行为。也就是说，需要关注的是一个类提供哪些行为</p>
<p>参考完档:</p>
<ol>
<li><a href="https://onevcat.com/2014/02/ios-test-with-kiwi/" target="_blank" rel="external">Kiwi 使用 –王巍 </a></li>
<li><a href="https://onevcat.com/2014/05/kiwi-mock-stub-test/" target="_blank" rel="external">Kiwi 使用进阶 –王巍 </a></li>
</ol>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="zhzDeveloper.github.io/2017/07/21/单元测试和集成测试/" data-id="cjbyrxo6i0041w9hlblkba2k9" class="article-share-link">分享</a><div class="tags"></div><div class="post-nav"><a href="/2017/12/18/React及React Native 安装/" class="pre"></a><a href="/2017/02/13/Python 爬虫初探/" class="next">Python 爬虫初探</a></div><div id="uyan_frame"></div><script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2144959"></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="zhzDeveloper.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS-分类/">iOS-分类</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios平台/">ios平台</a><span class="category-list-count">66</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios平台-UI控件/">ios平台,UI控件</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios平台-图片处理/">ios平台,图片处理</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios平台-开发工具/">ios平台,开发工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/swift/">swift</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发工具/">开发工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则/">正则</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机技巧/">计算机技巧</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/18/React及React Native 安装/">React及React Native 安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/21/单元测试和集成测试/">单元测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/13/Python 爬虫初探/">Python 爬虫初探</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/12/数组排序sortedArrayUsingComparator/">数组排序sortedArrayUsingComparator</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/macOS Sierra 找回消失的 “任何来源”/">macOS Sierra 找回消失的 “任何来源”</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/11/Method Swizzling(转载+补充)/">Method Swizzling(转载+补充)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/10/instancesRespondToSelector与respondsToSelector的区别/">instancesRespondToSelector与respondsToSelector的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/08/生成Description/">生成Description</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/26/忽略编译警告/">忽略编译警告</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/09/iOS-面试题整理/">iOS-面试题整理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/zhzDeveloper/" title="github" target="_blank">github</a><ul></ul><a href="http://blog.csdn.net/zhz459880251" title="blogs" target="_blank">blogs</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">zhz blogs.</a> Powered by<a rel="nofollow" target="_blank" href="https://github.com/zhzDeveloper"> zhz.</a><a rel="nofollow" target="_blank" href="http://zhzdeveloper.github.io/"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/zhzDeveloper"> zhz.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>