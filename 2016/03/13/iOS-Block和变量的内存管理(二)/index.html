<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS-Block和变量的内存管理(二) | zhz blogs</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS-Block和变量的内存管理(二)</h1><a id="logo" href="/.">zhz blogs</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS-Block和变量的内存管理(二)</h1><div class="post-meta">Mar 13, 2016<span> | </span><span class="category"><a href="/categories/ios平台/">ios平台</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p> 了解了 <a href="http://blog.csdn.net/zhz459880251/article/details/50878555" target="_blank" rel="external">block的实现</a>，我们接着来聊聊 block 和变量的内存管理。本文将介绍</p>
<blockquote>
<ol>
<li>可写变量</li>
<li>block的内存段</li>
<li>__block变量的内存段等内容</li>
</ol>
</blockquote>
<p> 看完本文会对 block 和变量的内存管理有更加清晰的认识。</p>
<p> 上篇文章举了个例子，在 block 内获取了一个外部的局部变量，可以读取，但无法进行写入的修改操作。在 C 语言中有三种类型的变量，可在 block 内进行读写操作</p>
<blockquote>
<ul>
<li>全局变量<ul>
<li>全局静态变量</li>
<li>静态变量</li>
</ul>
</li>
</ul>
</blockquote>
<p> <big><code>全局变量</code> 和 <code>全局静态变量</code> 由于作用域在全局，所以在 block 内访问和读写这两类变量和普通函数没什么区别，而 <code>静态变量</code> 作用域在 block 之外，是怎么对它进行读写呢？通过 clang 工具，我们发现原来 <code>静态变量 是通过指针传递</code>，将变量传递到 block 内，所以可以修改变量值。而上篇文章中的外部变量是通过值传递，自然没法对获取到的外部变量进行修改。<br> 由此，可以给我们一个启示，当我们需要修改外部变量时，是不是也可以像 静态变量 这样通过指针来修改外部变量的值呢？</big></p>
<p> Apple 早就为我们准备了这么一个东西 ——    <code>__block</code></p>
<h1 id="block-说明符"><a href="#block-说明符" class="headerlink" title="__block 说明符"></a>__block 说明符</h1><p> 按照惯例，重写一小段代码看看 __block 的真身<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/************* 使用 __block 的源码 *************/</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    __block int intValue = 0;</div><div class="line">    void (^blk)(void) = ^&#123;</div><div class="line">        intValue = 1;</div><div class="line">    &#125;;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">/************* 使用 clang 翻译后如下 *************/</div><div class="line">struct __block_impl</div><div class="line">&#123;</div><div class="line">    void *isa;</div><div class="line">    int Flags;</div><div class="line">    int Reserved;</div><div class="line">    void *FuncPtr;</div><div class="line">&#125;;</div><div class="line">struct __Block_byref_intValue_0</div><div class="line">&#123;</div><div class="line">    void *__isa;</div><div class="line">    __Block_byref_intValue_0 *__forwarding;</div><div class="line">    int __flags;</div><div class="line">    int __size;</div><div class="line">    int intValue;</div><div class="line">&#125;;</div><div class="line">struct __main_block_impl_0</div><div class="line">&#123;</div><div class="line">    struct __block_impl impl;</div><div class="line">    struct __main_block_desc_0* Desc;</div><div class="line">    __Block_byref_intValue_0 *intValue; // by ref</div><div class="line">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_intValue_0 *_intValue, int flags=0) : intValue(_intValue-&gt;__forwarding)</div><div class="line">    &#123;</div><div class="line">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">        impl.Flags = flags;</div><div class="line">        impl.FuncPtr = fp;</div><div class="line">        Desc = desc;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself)</div><div class="line">&#123;</div><div class="line">    __Block_byref_intValue_0 *intValue = __cself-&gt;intValue; // bound by ref</div><div class="line">    (intValue-&gt;__forwarding-&gt;intValue) = 1;</div><div class="line">&#125;</div><div class="line">static void __main_block_copy_0(struct __main_block_impl_0 *dst, struct __main_block_impl_0 *src)</div><div class="line">&#123;</div><div class="line">    _Block_object_assign((void*)&amp;dst-&gt;intValue, (void*)src-&gt;intValue, 8/*BLOCK_FIELD_IS_BYREF*/);</div><div class="line">&#125;</div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0 *src)</div><div class="line">&#123;</div><div class="line">    _Block_object_dispose((void*)src-&gt;intValue, 8/*BLOCK_FIELD_IS_BYREF*/);</div><div class="line">&#125;</div><div class="line">static struct __main_block_desc_0</div><div class="line">&#123;</div><div class="line">    size_t reserved;</div><div class="line">    size_t Block_size;</div><div class="line">    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">    void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123;  0, </div><div class="line">                                sizeof(struct __main_block_impl_0), </div><div class="line">                                __main_block_copy_0, </div><div class="line">                                __main_block_dispose_0</div><div class="line">                             &#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    __attribute__((__blocks__(byref))) __Block_byref_intValue_0 \</div><div class="line">    intValue = </div><div class="line">    &#123;</div><div class="line">        (void*)0,</div><div class="line">        (__Block_byref_intValue_0 *)&amp;intValue, </div><div class="line">        0, </div><div class="line">        sizeof(__Block_byref_intValue_0), </div><div class="line">        0</div><div class="line">    &#125;;</div><div class="line">    void (*blk)(void) = (void (*)()) &amp;__main_block_impl_0   \</div><div class="line">                (</div><div class="line">                    (void *)__main_block_func_0,            \</div><div class="line">                    &amp;__main_block_desc_0_DATA,              \</div><div class="line">                    (__Block_byref_intValue_0 *)&amp;intValue,  \</div><div class="line">                    570425344                               \</div><div class="line">                );</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 在加了 __block 之后，代码量增加了不少，仔细查看，其实只是比原来多了</p>
<blockquote>
<ol>
<li><code>__Block_byref_intValue_0</code>结构体：用于封装 __block 修饰的外部变量。<ol>
<li><code>_Block_object_assign</code> 函数：当 block 从栈拷贝到堆时，调用此函数。</li>
<li><code>_Block_object_dispose</code> 函数：当 block 从堆内存释放时，调用此函数。</li>
</ol>
</li>
</ol>
</blockquote>
<p> OC源码中的 <code>__block intValue</code> 翻译后变成了 <code>__Block_byref_intValue_0</code>结构体指针变量 <code>intValue</code>，通过指针传递到 block 内，这与前面说的 <code>静态变量</code> 的指针传递是一致的。除此之外，整体的执行流程与不加 <strong>block 基本一致，不再赘述。但 `</strong>Block_byref_intValue_0` 这个结构体需特别注意下</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 存储 __block 外部变量的结构体</div><div class="line">struct __Block_byref_intValue_0</div><div class="line">&#123;</div><div class="line">    void *__isa; // 对象指针</div><div class="line">    __Block_byref_intValue_0 *__forwarding; // 指向自己的指针</div><div class="line">    int __flags; // 标志位变量</div><div class="line">    int __size; // 结构体大小</div><div class="line">    int intValue; // 外部变量</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p> <img src="http://img.blog.csdn.net/20160313163243841" alt="这里写图片描述"><br> 在已有结构体指针指向 <code>__Block_byref_intValue_0</code> 时，结构体里面还多了个<code>__forwarding</code> 指向自己的指针变量，难道不显得多余吗？一点也不，本文后面会阐述。</p>
<hr>
<h1 id="block-的内存管理"><a href="#block-的内存管理" class="headerlink" title="block 的内存管理"></a>block 的内存管理</h1><p> 在前文中，已经提到了 block 的三种类型 <code>NSConcreteGlobalBlock</code>、<code>_NSConcreteStackBlock</code>、<code>_NSConcreteMallocBlock</code>，见名知意，可以看出三种 block 在内存中的分布</p>
<blockquote>
<p>在 ARC 开启的情况下，将只会有 <code>NSConcreteGlobalBlock</code> 和<code>NSConcreteMallocBlock</code>类型的 block。<br> 原本的 NSConcreteStackBlock 的 block 会被 NSConcreteMallocBlock 类型的 block 替代</p>
</blockquote>
<p>  <img src="http://img.blog.csdn.net/20160313163354404" alt="这里写图片描述"></p>
<h2 id="NSConcreteGlobalBlock"><a href="#NSConcreteGlobalBlock" class="headerlink" title="_NSConcreteGlobalBlock"></a>_NSConcreteGlobalBlock</h2><blockquote>
<p>1、当 block 字面量写在全局作用域时，即为 <code>global block</code>；<br> 2、当 block 字面量不获取任何外部变量时，即为 <code>global block</code>；</p>
</blockquote>
<p> <big>除了上述描述的两种情况，其他形式创建的 block 均为 <code>stack block</code>。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 下面 block 虽然定义在 for 循环内，但符合第二种情况，所以也是 global block</div><div class="line">typedef int (^blk_t)(int);</div><div class="line">for (int rate = 0; rate &lt; 10; ++rate) </div><div class="line">&#123;</div><div class="line">    blk_t blk = ^(int count)&#123;return rate * count;&#125;; </div><div class="line">&#125;</div></pre></td></tr></table></figure></big></p>
<p> <code>_NSConcreteGlobalBlock</code> 类型的 block 处于内存的 ROData 段，此处没有局部变量的骚扰，运行不依赖上下文，内存管理也简单的多。</p>
<h2 id="NSConcreteStackBlock"><a href="#NSConcreteStackBlock" class="headerlink" title="_NSConcreteStackBlock"></a>_NSConcreteStackBlock</h2><p> <code>_NSConcreteStackBlock</code> 类型的 block 处于内存的栈区。<code>global block</code> 由于处在 data 段，可以通过指针安全访问，但 <code>stack block</code> 处在内存栈区，如果其变量作用域结束，这个 block 就被废弃，block 上的 __block 变量也同样会被废弃。<br> <img src="http://img.blog.csdn.net/20160313163603436" alt="这里写图片描述"></p>
<p> 为了解决这个问题，block 提供了 copy 的功能，将 block 和 __block 变量从栈拷贝到堆，就是下面要说的 <code>_NSConcreteMallocBlock</code>。</p>
<h2 id="NSConcreteMallocBlock"><a href="#NSConcreteMallocBlock" class="headerlink" title="_NSConcreteMallocBlock"></a>_NSConcreteMallocBlock</h2><p> 当 block 从栈拷贝到堆后，当栈上变量作用域结束时，仍然可以继续使用 block</p>
<p> <img src="http://img.blog.csdn.net/20160313163641764" alt="这里写图片描述"></p>
<p> 此时，堆上的 block 类型为 <code>_NSConcreteMallocBlock</code>，所以会将 <code>_NSConcreteMallocBlock</code> 写入 isa</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">impl.isa = &amp;_NSConcreteMallocBlock;</div></pre></td></tr></table></figure>
<p> 如果你细心的观察上面的转换后的代码，会发现访问结构体 <code>__Block_byref_intValue_0</code> 内部的成员变量都是通过访问 <code>__forwarding</code> 指针完成的。为了保证能正确访问栈上的 <strong>block 变量，进行 copy 操作时，会将栈上的 `</strong>forwarding` 指针指向了堆上的 block 结构体实例。</p>
<hr>
<h1 id="block-的自动拷贝和手动拷贝"><a href="#block-的自动拷贝和手动拷贝" class="headerlink" title="block 的自动拷贝和手动拷贝"></a>block 的自动拷贝和手动拷贝</h1><p> 在开启 ARC 时，大部分情况下编译器通常会将创建在栈上的 block 自动拷贝到堆上，只有当</p>
<blockquote>
<p>block 作为方法或函数的参数传递时，编译器不会自动调用 copy 方法；</p>
</blockquote>
<p> 但方法/函数在内部已经实现了一份拷贝了 block 参数的代码，或者如果编译器自动拷贝，那么调用者就不需再手动拷贝，比如：</p>
<blockquote>
<ul>
<li>当 block 作为函数返回值返回时，编译器自动将 block 作为 <code>_Block_copy</code> 函数，效果等同于 block 直接调用 <code>copy</code> 方法；</li>
<li>当 block 被赋值给 __strong id 类型的对象或 block 的成员变量时，编译器自动将 block 作为 <code>_Block_copy</code> 函数，效果等同于 block 直接调用 <code>copy</code> 方法；</li>
<li>当 block 作为参数被传入方法名带有 <code>usingBlock</code> 的 Cocoa Framework 方法或 GCD 的 API 时。这些方法会在内部对传递进来的 block 调用<code>copy</code> 或 <code>_Block_copy</code> 进行拷贝;</li>
</ul>
</blockquote>
<p> 让我们看个 block 自动拷贝的例子<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/************ ARC下编译器自动拷贝block ************/</div><div class="line">typedef int (^blk_t)(int);</div><div class="line">blk_t func(int rate)</div><div class="line">&#123;</div><div class="line">    return ^(int count)&#123;return rate * count;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 上面的 block 获取了外部变量，所以是创建在栈上，当 <code>func</code> 函数返回给调用者时，脱离了局部变量<code>rate</code>的作用范围，如果调用者使用这个 block 就会出问题。<br> 那 ARC 开启的情况呢？运行这个 block 一切正常。和我们的预期结果不一样，ARC 到底给 block 施了什么魔法？我们将上面的代码翻译下<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">blk_t func(int rate)</div><div class="line">&#123;</div><div class="line">    blk_t tmp = &amp;__func_block_impl_0(__func_block_func_0, &amp;__func_block_desc_0_DATA, rate);</div><div class="line">    tmp = objc_retainBlock(tmp);</div><div class="line">    return objc_autoreleaseReturnValue(tmp); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 转换后出现两个新函数 <code>objc_retainBlock</code>、<code>objc_autoreleaseReturnValue</code>。如果你看过runtime 库（<a href="http://opensource.apple.com/tarballs/objc4/objc4-493.9.tar.gz" target="_blank" rel="external">点此下载</a>） ，在 runtime/objc-arr.mm 文件中就有这两个函数的实现：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> /*********** objc_retainBlock() 的实现 ***********/</div><div class="line"> id objc_retainBlock(id x) </div><div class="line"> &#123;</div><div class="line"># if ARR_LOGGING</div><div class="line">     objc_arr_log(&quot;objc_retain_block&quot;, x);</div><div class="line">     ++CompilerGenerated.blockCopies;</div><div class="line"># endif</div><div class="line">     return (id)_Block_copy(x);</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> // Create a heap based copy of a Block or simply add a reference to an existing one.</div><div class="line"> // This must be paired with Block_release to recover memory, even when running</div><div class="line"> // under Objective-C Garbage Collection.</div><div class="line"> BLOCK_EXPORT void *_Block_copy(const void *aBlock)</div><div class="line">     __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</div></pre></td></tr></table></figure></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> /*********** objc_autoreleaseReturnValue() 的实现 ***********/</div><div class="line"> id objc_autoreleaseReturnValue(id obj)</div><div class="line"> &#123;</div><div class="line"># if SUPPORT_RETURN_AUTORELEASE</div><div class="line">     assert(_pthread_getspecific_direct(AUTORELEASE_POOL_RECLAIM_KEY) == NULL);</div><div class="line">     if (callerAcceptsFastAutorelease(__builtin_return_address(0))) &#123;</div><div class="line">         _pthread_setspecific_direct(AUTORELEASE_POOL_RECLAIM_KEY, obj);</div><div class="line">         return obj;</div><div class="line">     &#125;</div><div class="line"># endif</div><div class="line">     return objc_autorelease(obj);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p> 通过上面的代码和注释，意思就很明显了，由于 block 字面量是创建在栈内存，通过 <code>objc_retainBlock()</code> 函数拷贝到堆内存，让<code>tmp</code> 重新指向堆上的 block，然后将<code>tmp</code>所指的堆上的 block 作为一个 Objective-C 对象放入 autoreleasepool 里面，从而保证了返回后的 block 仍然可以正确执行。</p>
<p> 看完了 block 的自动拷贝，那么看看在 ARC 下需要手动拷贝 block 的例子<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/************ ARC下编译器手动拷贝block ************/</div><div class="line">- (id)getBlockArray</div><div class="line">&#123;</div><div class="line">    int val = 10;</div><div class="line">    return [[NSArray alloc] initWithObjects: </div><div class="line">                            ^&#123;NSLog(@&quot;blk0:%d&quot;, val);&#125;, </div><div class="line">                            ^&#123;NSLog(@&quot;blk1:%d&quot;, val);&#125;, nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 一个例子就了然，返回的数组里面的 block 是不可用的，需要再手动拷贝一次才可以，这个较为简单，就不作过多解释。</p>
<p> 关于 block 的拷贝操作可以用一张表总结下</p>
<p>  <img src="http://img.blog.csdn.net/20160313164225094" alt="这里写图片描述"></p>
<p> block 拷贝的讲解就到此为止，有兴趣可以了解下 block 的多次拷贝。</p>
<blockquote>
<p><big> block的多次拷贝</big>：下面的例子在 ARC 下并不会产生内存泄露哦</p>
 <figure class="highlight plain"><figcaption><span>block 多次拷贝源码</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">blk = [[[[blk copy] copy] copy] copy]; </div><div class="line">// 翻译后的代码</div><div class="line">&#123;</div><div class="line">    blk_t tmp = [blk copy];</div><div class="line">    blk = tmp; </div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">    blk_t tmp = [blk copy];</div><div class="line">    blk = tmp; </div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">    blk_t tmp = [blk copy];</div><div class="line">    blk = tmp; </div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">    blk_t tmp = [blk copy];</div><div class="line">    blk = tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
<hr>
<h1 id="block-变量的内存管理"><a href="#block-变量的内存管理" class="headerlink" title="__block 变量的内存管理"></a>__block 变量的内存管理</h1><p> 上面啰嗦一堆，这小节主要用图说话，必要时加文字说明。</p>
<ul>
<li><p>当 block 从栈内存被拷贝到堆内存时，<strong>block 变量的变化如下图。需要说明的是，当栈上的 block 被拷贝到堆上，堆上的 block 再次被拷贝时，对 </strong>block 变量已经没有影响了。</p>
<p><img src="http://img.blog.csdn.net/20160313164520259" alt="这里写图片描述"></p>
</li>
</ul>
<ul>
<li><p>当多个 block 获取同一个 __block 变量，block 从栈被拷贝到堆时<br><img src="http://img.blog.csdn.net/20160313164605158" alt="这里写图片描述"></p>
</li>
<li><p>当 block 被废弃时，__block 变量被释放<br><img src="http://img.blog.csdn.net/20160313164645908" alt="这里写图片描述"></p>
</li>
<li><p><strong>forwarding<br>   前文已经说过，当 block 从栈被拷贝到堆时，`</strong>forwarding<code>指针变量也会指向堆区的结构体。但是为什么要这么做呢？为什么要让原本指向栈区的结构体的指针，去指向堆区的结构体呢？看起来匪夷所思，实则原因很简单，要从</code><strong>forwarding<code>产生的缘由说起。想想起初为什么要给 block 添加 copy 的功能，就是因为 block 获取了局部变量，当要在其他地方（超出局部变量作用范围）使用这个 block 的时候，由于访问局部变量异常，导致程序崩溃。为了解决这个问题，就给 block 添加了 copy 功能。在将 block 拷贝到堆上的同时，将</code></strong>forwarding<code>指针指向堆上结构体。后面如果要想使用 __block 变量，只要通过</code>__forwarding` 访问堆上变量，就不会出现程序崩溃了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/*************** __forwarding 的作用 ***************/</div><div class="line">//猜猜下面代码的打印结果？</div><div class="line">&#123;</div><div class="line">    __block int val = 0;</div><div class="line">    void (^blk)(void) = [^&#123;++val;&#125; copy];</div><div class="line">    ++val;</div><div class="line">    blk();</div><div class="line">    NSLog(@&quot;%d&quot;, val);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一定有很多人会猜<code>1</code>，其实打印 <code>2</code>。原因很简单，当栈上的 block 被拷贝到堆上时，栈上的 <code>__forwarding</code> 也会指向<code>堆</code>上的 __block 变量的结构体。</p>
<p>上面的代码中<code>^{++val;}</code> 和 <code>++val;</code> 都会被转换成 <code>++(val.__forwarding-&gt;val);</code>，<code>堆</code>上的 <code>val 被加了两次</code>，最后打印堆上的 val 为<code>2</code>。</p>
<blockquote>
<p>图解<img src="http://img.blog.csdn.net/20160313165113941" alt="这里写图片描述"></p>
</blockquote>
</li>
</ul>
<hr>
<p> block 和变量的内存管理终于讲完了，看似很长，只要了解本质，其实很简单。<br> 下篇文章: <a href="http://blog.csdn.net/zhz459880251/article/details/50878858" target="_blank" rel="external">block和对象的内存管理(三)</a>。</p>
<p> 原文地址: <a href="https://www.zybuluo.com/MicroCai/note/57603" target="_blank" rel="external">https://www.zybuluo.com/MicroCai/note/57603</a></p>
<p> 原文链接: <a href="http://blog.csdn.net/zhz459880251/article/details/50878740" target="_blank" rel="external">http://blog.csdn.net/zhz459880251/article/details/50878740</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="zhzDeveloper.github.io/2016/03/13/iOS-Block和变量的内存管理(二)/" data-id="cj7lqjyol002tlvhlimhwwa6e" class="article-share-link">分享</a><div class="tags"></div><div class="post-nav"><a href="/2016/03/13/iOS-Block和对象的内存管理(三)/" class="pre">iOS-Block和对象的内存管理(三)</a><a href="/2016/03/13/iOS-Block的实现(一)/" class="next">iOS-Block的实现(一)</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="zhzDeveloper.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS-分类/">iOS-分类</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios平台/">ios平台</a><span class="category-list-count">66</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios平台-UI控件/">ios平台,UI控件</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios平台-图片处理/">ios平台,图片处理</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios平台-开发工具/">ios平台,开发工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/swift/">swift</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发工具/">开发工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则/">正则</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机技巧/">计算机技巧</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/21/单元测试和集成测试/">单元测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/13/Python 爬虫初探/">Python 爬虫初探</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/12/数组排序sortedArrayUsingComparator/">数组排序sortedArrayUsingComparator</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/macOS Sierra 找回消失的 “任何来源”/">macOS Sierra 找回消失的 “任何来源”</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/11/Method Swizzling(转载+补充)/">Method Swizzling(转载+补充)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/10/instancesRespondToSelector与respondsToSelector的区别/">instancesRespondToSelector与respondsToSelector的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/08/生成Description/">生成Description</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/26/忽略编译警告/">忽略编译警告</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/09/iOS-面试题整理/">iOS-面试题整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/07/GCD小结/">GCD小结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">zhz blogs.</a> Powered by<a rel="nofollow" target="_blank" href="https://github.com/zhzDeveloper"> zhz.</a><a rel="nofollow" target="_blank" href="http://zhzdeveloper.github.io/"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/zhzDeveloper"> zhz.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>