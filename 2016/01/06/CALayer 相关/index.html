<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>CALayer 相关 | zhz blogs</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CALayer 相关</h1><a id="logo" href="/.">zhz blogs</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">CALayer 相关</h1><div class="post-meta">Jan 6, 2016<span> | </span><span class="category"><a href="/categories/ios平台/">ios平台</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p> 在iOS当中，所有的视图都从一个叫做UIVIew的基类派生而来，UIView可以处理触摸事件，可以支持基于<code>Core Graphics</code>绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。</p>
<h1 id="CALayer概念"><a href="#CALayer概念" class="headerlink" title="CALayer概念"></a>CALayer概念</h1><p> CALayer也是一些被层级关系树管理的<code>矩形块</code>，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。和UIView最大的不同是<code>CALayer不处理用户的交互</code>。<br>  每一个UIview都有一个CALayer实例的图层属性,  这些图层才是真正用来在屏幕上显示和做动画，<code>UIView仅仅是对它的一个封装</code>，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。</p>
<h1 id="CALayer用途"><a href="#CALayer用途" class="headerlink" title="CALayer用途"></a>CALayer用途</h1><p> UIView的高级API间接地使得动画变得很简单。<br> 但UIView还有没有暴露出来的CALayer的功能：</p>
<blockquote>
<ol>
<li>阴影，圆角，带颜色的边框<ol>
<li>3D变换</li>
<li>非矩形范围</li>
<li>透明遮罩</li>
<li>多级非线性动画</li>
</ol>
</li>
</ol>
</blockquote>
<h1 id="CALayer创建"><a href="#CALayer创建" class="headerlink" title="CALayer创建"></a>CALayer创建</h1><p> 创建layer的创建和创建View其实差不多</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CALayer *blueLayer = [CALayer layer];</div><div class="line">	//1. 设置 frame</div><div class="line">    blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);</div><div class="line">    //2. 设置背景色</div><div class="line">    blueLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">    //添加到父layer上</div><div class="line">    [self.view.layer addSublayer:blueLayer];</div></pre></td></tr></table></figure>
<h3 id="CALayer属性"><a href="#CALayer属性" class="headerlink" title="CALayer属性"></a>CALayer属性</h3><h4 id="1-contents-寄宿图-类型被定义为id-但是其实是CGImage类型的"><a href="#1-contents-寄宿图-类型被定义为id-但是其实是CGImage类型的" class="headerlink" title="1. contents: 寄宿图,  类型被定义为id, 但是其实是CGImage类型的;"></a>1. contents: 寄宿图,  类型被定义为id, 但是其实是<code>CGImage</code>类型的;</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">layer.contents = (__bridge id)image.CGImage;</div></pre></td></tr></table></figure>
<p> 注意: 如果使用ARC,  <code>__bridge</code>没必要使用</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UIImage *image = [UIImage imageNamed:@&quot;1.png&quot;];</div><div class="line">self.layerView.layer.contents = (id)image.CGImage;</div></pre></td></tr></table></figure>
<p> 这样一个不需要UIImageView就能显示图片的额View就建立起来了.</p>
<h4 id="2-contentGravity-对contents中显示的图片伸缩处理"><a href="#2-contentGravity-对contents中显示的图片伸缩处理" class="headerlink" title="2. contentGravity: 对contents中显示的图片伸缩处理"></a>2. contentGravity: 对contents中显示的图片伸缩处理</h4><p> 在UIImageView中如果图片拉伸了, 解决方法就是把contentMode属性设置成更合适的值，像这样：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.contentMode = UIViewContentModeScaleAspectFit;</div></pre></td></tr></table></figure></p>
<p> CALayer与contentMode对应的属性叫做<code>contentsGravity</code>，但是它是一个NSString类型。contentsGravity可选的常量值有以下一些：</p>
<blockquote>
<p>kCAGravityCenter<br>  kCAGravityTop<br> kCAGravityBottom<br> kCAGravityLeft<br> kCAGravityRight<br> kCAGravityTopLeft<br> kCAGravityTopRight<br> kCAGravityBottomLeft<br> kCAGravityBottomRight<br> kCAGravityResize<br> kCAGravityResizeAspect<br> kCAGravityResizeAspectFill</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.view.layer.contentsGravity = kCAGravityResizeAspect;</div></pre></td></tr></table></figure>
<h4 id="2-contentsScale-寄宿图的像素尺寸和视图大小的比例-默认为1-0"><a href="#2-contentsScale-寄宿图的像素尺寸和视图大小的比例-默认为1-0" class="headerlink" title="2. contentsScale: 寄宿图的像素尺寸和视图大小的比例, 默认为1.0;"></a>2. contentsScale: 寄宿图的像素尺寸和视图大小的比例, 默认为1.0;</h4><p> 如果设置了<code>contentsGravity = kCAGravityResizeAspect</code>属性，说明寄宿图已经被拉伸以适应图层的边界,  所以再设置contentsScale对屏幕上的寄宿图没有影响.<code>contentsGravity = kCAGravityCenter</code>有很明显的变化<br> 如果contentsScale设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.view.layer.contentsScale = [UIScreen mainScreen].scale;</div></pre></td></tr></table></figure>
<h4 id="3-maskToBounds-超出边界是否剪切-bool类型"><a href="#3-maskToBounds-超出边界是否剪切-bool类型" class="headerlink" title="3. maskToBounds: 超出边界是否剪切, bool类型"></a>3. maskToBounds: 超出边界是否剪切, bool类型</h4><p> UIView有一个叫做clipsToBounds的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做masksToBounds</p>
<p> YES: 超出部分 不显示<br> NO: 超出部分也显示</p>
<h4 id="4-contentsRect-显示寄宿图的一个子域"><a href="#4-contentsRect-显示寄宿图的一个子域" class="headerlink" title="4. contentsRect: 显示寄宿图的一个子域"></a>4. contentsRect: 显示寄宿图的一个子域</h4><p> CALayer的<code>contentsRect</code>属性允许我们在图层边框里显示寄宿图的一个子域。</p>
<p> 和bounds，frame不同，contentsRect<code>不是按点来计算的</code>，它使用了<code>单位坐标</code>，<code>单位坐标指定在0到1之间，是一个相对值（像素和点就是绝对值）</code>。所以他们是相对与寄宿图的尺寸的。iOS使用了以下的坐标系统：</p>
<blockquote>
<p><strong>点</strong> —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2<em>2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。<br> <strong>像素</strong> —— 物理像素坐标并不会用来屏幕布局，但是仍然与图片有相对关系。UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备上，他们表现出来了不同的大小。<br> <em>*单位</em></em> —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。<br> 默认的contentsRect是{0, 0, 1, 1}，这意味着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪</p>
</blockquote>
<p> <code>默认的contentsRect是{0, 0, 1, 1}</code>，这意味着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪<br> 事实上给contentsRect设置一个负数的原点或是大于{1, 1}的尺寸也是可以的。这种情况下，最外面的像素会被拉伸以填充剩下的区域。</p>
<p> contentsRect另一个重要用途:<br> <code>拼合技术</code>–图片拼合后可以打包整合到一张大图上一次性载入。相比多次载入不同的图片，这样做能够带来很多方面的好处：内存使用，载入时间，渲染性能等等<br> 规则很简单：像平常一样载入我们的大图，然后把它赋值给四个独立的图层的contents，然后设置每个图层的contentsRect来去掉我们不想显示的部分。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *coneView;</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *shipView;</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *iglooView;</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *anchorView;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad </div><div class="line">&#123;</div><div class="line">  [super viewDidLoad]; //load sprite sheet</div><div class="line">  UIImage *image = [UIImage imageNamed:@&quot;Sprites.png&quot;];</div><div class="line">  //set igloo sprite</div><div class="line">  [self addSpriteImage:image withContentRect:CGRectMake(0, 0, 0.5, 0.5) toLayer:self.iglooView.layer];</div><div class="line">  //set cone sprite</div><div class="line">  [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0, 0.5, 0.5) toLayer:self.coneView.layer];</div><div class="line">  //set anchor sprite</div><div class="line">  [self addSpriteImage:image withContentRect:CGRectMake(0, 0.5, 0.5, 0.5) toLayer:self.anchorView.layer];</div><div class="line">  //set spaceship sprite</div><div class="line">  [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0.5, 0.5, 0.5) toLayer:self.shipView.layer];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)addSpriteImage:(UIImage *)image withContentRect:(CGRect)rect ￼toLayer:(CALayer *)layer //set image</div><div class="line">&#123;</div><div class="line">  layer.contents = (__bridge id)image.CGImage;</div><div class="line"></div><div class="line">  //scale contents to fit</div><div class="line">  layer.contentsGravity = kCAGravityResizeAspect;</div><div class="line"></div><div class="line">  //set contentsRect</div><div class="line">  layer.contentsRect = rect;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p> Mac上有一些商业软件可以为你自动拼合图片，这些工具自动生成一个包含拼合后的坐标的XML或者plist文件，拼合图片的使用大大简化。这个文件可以和图片一同载入，并给每个拼合的图层设置contentsRect，这样开发者就不用手动写代码来摆放位置了。</p>
<h4 id="5-contentsCenter-与-UIImage里的-resizableImageWithCapInsets-方法效果非常类似"><a href="#5-contentsCenter-与-UIImage里的-resizableImageWithCapInsets-方法效果非常类似" class="headerlink" title="5. contentsCenter: 与 UIImage里的-resizableImageWithCapInsets: 方法效果非常类似"></a>5. contentsCenter: 与 UIImage里的-resizableImageWithCapInsets: 方法效果非常类似</h4><p> 用于layer边界的拉伸<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">layer.contentsCenter = CGRectMake(0.25, 0.25, 0.5, 0.5)</div></pre></td></tr></table></figure></p>
<h4 id="7-conrnerRadius-圆角弧度"><a href="#7-conrnerRadius-圆角弧度" class="headerlink" title="7.conrnerRadius: 圆角弧度"></a>7.conrnerRadius: 圆角弧度</h4><p> 默认情况下，这个曲率值只影响背景颜色而不影响背景图片或是子图层</p>
<h4 id="8-borderWidth-边框宽度"><a href="#8-borderWidth-边框宽度" class="headerlink" title="8.borderWidth: 边框宽度"></a>8.borderWidth: 边框宽度</h4><p>  这条线（也被称作stroke）沿着图层的bounds绘制，同时也包含图层的角</p>
<h4 id="9-borderColor-边框颜色-CGColorRef"><a href="#9-borderColor-边框颜色-CGColorRef" class="headerlink" title="9.borderColor: 边框颜色, CGColorRef"></a>9.borderColor: 边框颜色, CGColorRef</h4><p> CGColorRef属性即便是强引用也只能通过assign关键字来声明<br> borderColor定义了边框的颜色，默认为黑色</p>
<p> 边框是绘制在图层边界里面的，而且在所有子内容之前，也在子图层之前</p>
<h4 id="10-conrnerRadius-圆角弧度"><a href="#10-conrnerRadius-圆角弧度" class="headerlink" title="10.conrnerRadius: 圆角弧度"></a>10.conrnerRadius: 圆角弧度</h4><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><h4 id="11-shadowOpacity-必须在0-0（不可见）和1-0（完全不透明）之间的浮点数"><a href="#11-shadowOpacity-必须在0-0（不可见）和1-0（完全不透明）之间的浮点数" class="headerlink" title="11. shadowOpacity: 必须在0.0（不可见）和1.0（完全不透明）之间的浮点数"></a>11. shadowOpacity: 必须在0.0（不可见）和1.0（完全不透明）之间的浮点数</h4><p> 使用CALayer的另外三个属性：shadowColor，shadowOffset和shadowRadius。</p>
<h4 id="12-shadowColor-属性控制着阴影的颜色"><a href="#12-shadowColor-属性控制着阴影的颜色" class="headerlink" title="12. shadowColor: 属性控制着阴影的颜色"></a>12. shadowColor: 属性控制着阴影的颜色</h4><p> 和borderColor和backgroundColor一样，它的类型也是CGColorRef。阴影默认是黑色</p>
<h4 id="13-shadowOffset-属性控制着阴影的方向和距离"><a href="#13-shadowOffset-属性控制着阴影的方向和距离" class="headerlink" title="13. shadowOffset: 属性控制着阴影的方向和距离"></a>13. shadowOffset: 属性控制着阴影的方向和距离</h4><p> 它是一个CGSize的值，宽度控制这阴影横向的位移，高度控制着纵向的位移。shadowOffset的默认值是 {0, -3}，意即阴影相对于Y轴有3个点的向上位移。</p>
<h4 id="14-shadowRadius属性控制着阴影的模糊度"><a href="#14-shadowRadius属性控制着阴影的模糊度" class="headerlink" title="14. shadowRadius属性控制着阴影的模糊度"></a>14. shadowRadius属性控制着阴影的模糊度</h4><p> 当它的值是0的当值越来越大的时候，边界线看上去就会越来越模糊和自然。苹果自家的应用设计更偏向于自然的阴影，所以一个非零值再合适不过了。<br> shadowRadius属性控制着阴影的模糊度，当它的值是0的时候，阴影就和视图一样有一个非常确定的边界线</p>
<h4 id="15-shadowPath"><a href="#15-shadowPath" class="headerlink" title="15. shadowPath:"></a>15. shadowPath:</h4><p> 我们已经知道图层阴影并不总是方的，而是从图层内容的形状继承而来<br> 但是实时计算阴影也是一个非常消耗资源的，尤其是图层有多个子图层，每个图层还有一个有透明效果的寄宿图的时候。<br>     如果你事先知道你的阴影形状会是什么样子的，你可以通过指定一个shadowPath来提高性能<br>     如果是一个矩形或者是圆，用CGPath会相当简单明了。但是如果是更加复杂一点的图形，UIBezierPath类会更合适，它是一个由UIKit提供的在CGPath基础上的Objective-C包装类。</p>
<h4 id="16-opacity-透明度"><a href="#16-opacity-透明度" class="headerlink" title="16. opacity: 透明度"></a>16. opacity: 透明度</h4><h2 id="CALayer子类"><a href="#CALayer子类" class="headerlink" title="CALayer子类"></a>CALayer子类</h2><h3 id="1-CAShapeLayer"><a href="#1-CAShapeLayer" class="headerlink" title="1. CAShapeLayer"></a>1. CAShapeLayer</h3><p> CAShapeLayer是一个通过矢量图形而不是bitmap来绘制的图层子类。你指定诸如颜色和线宽等属性，用CGPath来定义想要绘制的图形，最后CAShapeLayer就自动渲染出来了。</p>
<p> 当然，你也可以用Core Graphics直接向原始的CALyer的内容中绘制一个路径，相比直下，使用CAShapeLayer有以下一些优点：</p>
<blockquote>
<p>渲染快速。CAShapeLayer使用了硬件加速，绘制同一图形会比用Core Graphics快很多。<br> 高效使用内存。一个CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。<br> 不会被图层边界剪裁掉。一个CAShapeLayer可以在边界之外绘制。你的图层路径不会像在使用Core Graphics的普通CALayer一样被剪裁掉（如我们在第二章所见）。<br> 不会出现像素化。当你给CAShapeLayer做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化。</p>
</blockquote>
<p> 属性比如<br> lineWith（线宽，用点表示单位），<br> lineCap（线条结尾的样子），<br> lineJoin（线条之间的结合点的样子）；<br> 在下一篇时会详细说明一些用法, 及一些事亻列, </p>
<h3 id="2-CATextLayer"><a href="#2-CATextLayer" class="headerlink" title="2. CATextLayer"></a>2. CATextLayer</h3><p> Core Animation提供了一个CALayer的子类CATextLayer，它以图层的形式包含了UILabel几乎所有的绘制特性，并且额外提供了一些新的特性。<br> CATextLayer也要比UILabel渲染得快得多<br> 如果我们想以Retina的质量来显示文字，我们就得手动地设置CATextLayer的contentsScale属性，如下：<br> textLayer.contentsScale = [UIScreen mainScreen].scale;</p>
<h3 id="3-CATransformLayer"><a href="#3-CATransformLayer" class="headerlink" title="3. CATransformLayer"></a>3. CATransformLayer</h3><h3 id="4-CAGradientLayer"><a href="#4-CAGradientLayer" class="headerlink" title="4. CAGradientLayer"></a>4. CAGradientLayer</h3><p> CAGradientLayer是用来生成两种或更多颜色平滑渐变的。用Core Graphics复制一个CAGradientLayer并将内容绘制到一个普通图层的寄宿图也是有可能的，但是CAGradientLayer的真正好处在于绘制使用了硬件加速。</p>
<p> 有startPoint和endPoint属性，他们决定了渐变的方向。这两个参数是以单位坐标系进行的定义，所以左上角坐标是{0, 0}，右下角坐标是{1, 1}。</p>
<p> 下一篇详细介绍, 及一些事例</p>
<h3 id="5-CAReplicatorLayer-处理相似图层"><a href="#5-CAReplicatorLayer-处理相似图层" class="headerlink" title="5. CAReplicatorLayer: 处理相似图层"></a>5. CAReplicatorLayer: 处理相似图层</h3><p> CAReplicatorLayer的目的是为了高效生成许多相似的图层。它会绘制一个或多个图层的子图层，并在每个复制体上应用不同的变换。<br> <code>instanceCount</code>属性指定了图层需要重复多少次。<br> <code>instanceTransform</code>指定了一个CATransform3D3D变换（这种情况下，下一图层的位移和旋转将会移动到圆圈的下一个点）。<br> instanceBlueOffset和instanceGreenOffset: 逐步减少蓝色和绿色通道<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">CAReplicatorLayer *layer = (CAReplicatorLayer *)self.layer;</div><div class="line">    layer.instanceCount = 2;</div><div class="line"></div><div class="line">    //move reflection instance below original and flip vertically</div><div class="line">    CATransform3D transform = CATransform3DIdentity;</div><div class="line">    CGFloat verticalOffset = self.bounds.size.height + 2;</div><div class="line">    transform = CATransform3DTranslate(transform, 0, verticalOffset, 0);</div><div class="line">    transform = CATransform3DScale(transform, 1, -1, 0);</div><div class="line">    layer.instanceTransform = transform;</div><div class="line"></div><div class="line">    //reduce alpha of reflection layer</div><div class="line">    layer.instanceAlphaOffset = -0.6;</div></pre></td></tr></table></figure></p>
<h3 id="6-CAScrollLayer"><a href="#6-CAScrollLayer" class="headerlink" title="6. CAScrollLayer"></a>6. CAScrollLayer</h3><h3 id="7-CATiledLayer"><a href="#7-CATiledLayer" class="headerlink" title="7. CATiledLayer"></a>7. CATiledLayer</h3><p> CATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入</p>
<h3 id="8-CAEmitterLayer"><a href="#8-CAEmitterLayer" class="headerlink" title="8. CAEmitterLayer"></a>8. CAEmitterLayer</h3><p> 在iOS 5中，苹果引入了一个新的CALayer子类叫做CAEmitterLayer。CAEmitterLayer是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果。</p>
<h3 id="9-AVPlayerLayer"><a href="#9-AVPlayerLayer" class="headerlink" title="9. AVPlayerLayer"></a>9. AVPlayerLayer</h3><p> 它不是Core Animation框架的一部分（AV前缀看上去像），AVPlayerLayer是有别的框架（AVFoundation）提供的，它和Core Animation紧密地结合在一起，提供了一个CALayer子类来显示自定义的内容类型。<br> AVPlayerLayer是用来在iOS上播放视频的。他是高级接口例如MPMoivePlayer的底层实现，提供了显示视频的底层控制。AVPlayerLayer的使用相当简单：你可以用+playerLayerWithPlayer:方法创建一个已经绑定了视频播放器的图层，或者你可以先创建一个图层，然后用player属性绑定一个AVPlayer实例。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">NSURL *URL = [[NSBundle mainBundle] URLForResource:@&quot;Ship&quot; withExtension:@&quot;mp4&quot;];</div><div class="line"></div><div class="line">    //create player and player layer</div><div class="line">    AVPlayer *player = [AVPlayer playerWithURL:URL];</div><div class="line">    AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player];</div><div class="line"></div><div class="line">    //set player layer frame and attach it to our view</div><div class="line">    playerLayer.frame = self.containerView.bounds;</div><div class="line">    [self.containerView.layer addSublayer:playerLayer];</div><div class="line"></div><div class="line">    //play the video</div><div class="line">    [player play];</div></pre></td></tr></table></figure>
<p> 我们用代码创建了一个AVPlayerLayer，但是我们仍然把它添加到了一个容器视图中，而不是直接在controller中的主视图上添加。这样其实是为了可以使用自动布局限制使得图层在最中间；否则，一旦设备被旋转了我们就要手动重新放置位置，因为Core Animation并不支持自动大小和自动布局</p>
<p> AVPlayerLayer是CALayer的子类，它继承了父类的所有特性。我们并不会受限于要在一个矩形中播放视频；圆角，有色边框，蒙板，阴影等效果</p>
<h1 id="CALayer自定义绘制"><a href="#CALayer自定义绘制" class="headerlink" title="CALayer自定义绘制"></a>CALayer自定义绘制</h1><p> 给contents赋CGImage的值不是唯一的设置寄宿图的方法。我们也可以直接用Core Graphics直接绘制寄宿图。能够通过继承UIView并实现<code>-drawRect:</code>方法来自定义绘制。<br> <code>-drawRect:</code>方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到-drawRect: 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于<code>视图大小乘以 contentsScale</code>的值</p>
<p> 但是创建<code>-drawRect:</code>会造成CPU资源和内存的浪费;<br> 当<code>视图在屏幕上出现</code>的时候 -drawRect:方法就会被自动调用。-drawRect:方法里面的代码利用Core Graphics去绘制一个寄宿图</p>
<h1 id="图层几何"><a href="#图层几何" class="headerlink" title="图层几何"></a>图层几何</h1><p> UIView有三个比较重要的布局属性：<code>frame</code>，<code>bounds</code>和<code>center</code>，CALayer对应地叫做<code>frame</code>，<code>bounds</code>和<code>position</code>。为了能清楚区分，图层用了“position”，视图用了“center”，但是他们都代表同样的值。</p>
<p> <code>frame</code>: 代表了图层的外部坐标（也就是在父图层上占据的空间）<br> <code>bounds</code>是内部坐标（{0, 0}通常是图层的左上角）<br> <code>center</code>和<code>position</code>都代表了相对于父图层anchorPoint(中心点)所在的位置</p>
<p> 视图的frame，bounds和center属性仅仅是存取方法，当操纵视图的frame，实际上是在改变位于视图下方CALayer的frame，不能够独立于图层之外改变视图的frame。</p>
<p>  注意:  1. 对于视图或者图层来说，frame并不是一个非常清晰的属性，它其实是一个虚拟属性，是<code>根据bounds，position和transform计算而来</code>，所以当其中任何一个值发生改变，frame都会变化。相反，改变frame的值同样会影响到他们当中的值</p>
<ol>
<li>当对图层做变换的时候，比如旋转或者缩放，frame实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说frame的宽高可能和bounds的宽高不再一致了<br><img src="http://img.blog.csdn.net/20160106154551673" alt="这里写图片描述"></li>
</ol>
<h1 id="anchorPoint锚点"><a href="#anchorPoint锚点" class="headerlink" title="anchorPoint锚点"></a>anchorPoint锚点</h1><p> 视图的center属性和图层的position属性都指定了anchorPoint相对于父图层的位置。图层的anchorPoint通过position来控制它的frame的位置，你可以认为anchorPoint是用来移动图层的把柄。</p>
<p> 默认来说，anchorPoint位于图层的中点，所以图层的将会以这个点为中心放置。anchorPoint属性并没有被UIView接口暴露出来，这也是视图的position属性被叫做“center”的原因。但是图层的anchorPoint可以被移动，比如你可以把它置于图层frame的左上角，于是图层的内容将会向右下角的position方向移动，而不是居中了。<br> <img src="http://img.blog.csdn.net/20160106155306778" alt="这里写图片描述"></p>
<p> contentsRect和contentsCenter属性类似，anchorPoint用<code>单位坐标</code>来描述，也就是图层的相对坐标，图层左上角是{0, 0}，右下角是{1, 1}，因此默认坐标是<code>{0.5, 0.5}</code>。anchorPoint可以通过指定x和y值小于0或者大于1，使它放置在图层范围之外。</p>
<h1 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h1><p> 一个图层的position依赖于它父图层的bounds<br> CALayer给不同坐标系之间的图层转换提供了一些工具类方法:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer *)layer;</div><div class="line">- (CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer *)layer;</div><div class="line">- (CGRect)convertRect:(CGRect)rect fromLayer:(CALayer *)layer;</div><div class="line">- (CGRect)convertRect:(CGRect)rect toLayer:(CALayer *)layer;</div></pre></td></tr></table></figure></p>
<p> 这些方法可以把定义在一个图层坐标系下的点或者矩形转换成另一个图层坐标系下的点或者矩形.</p>
<h2 id="Z坐标"><a href="#Z坐标" class="headerlink" title="Z坐标"></a>Z坐标</h2><p> 和UIView严格的二维坐标系不同，CALayer存在于一个三维空间当中。除了position和anchorPoint属性之外，还有zPosition和anchorPointZ，二者都是在Z轴上描述图层位置的浮点类型。<br> zPosition最实用的功能就是<code>改变图层</code>的显示顺序了<br> 给zPosition提高一个像素就可以改变视图显示顺序,<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.greenView.layer.zPosition = 1.0f;</div></pre></td></tr></table></figure></p>
<h1 id="Hit-Testing"><a href="#Hit-Testing" class="headerlink" title="Hit Testing"></a>Hit Testing</h1><p> CALayer并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。但是它有一系列的方法帮你处理事件：<br> <code>- containsPoint:</code>和<code>- hitTest:</code>。<br> <code>- containsPoint:</code>接受一个在本图层坐标系下的CGPoint，如果这个点在图层frame范围内就返回YES。这需要把触摸坐标转换成每个图层坐标系下的坐标<br> <code>-hitTest:</code>方法同样接受一个CGPoint类型参数，它返回不是BOOL类型，而是<code>图层本身</code>，或者包含这个坐标点的叶子节点图层。如果这个点在最外面图层的范围之外，则返回nil。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    //get touch position</div><div class="line">    CGPoint point = [[touches anyObject] locationInView:self.view];</div><div class="line">    //get touched layer</div><div class="line">    CALayer *layer = [self.layerView.layer hitTest:point];</div><div class="line">    //get layer using hitTest</div><div class="line">    if (layer == self.blueLayer) &#123;</div><div class="line">        [[[UIAlertView alloc] initWithTitle:@&quot;Inside Blue Layer&quot;</div><div class="line">                                    message:nil</div><div class="line">                                   delegate:nil</div><div class="line">                          cancelButtonTitle:@&quot;OK&quot;</div><div class="line">                          otherButtonTitles:nil] show];</div><div class="line">    &#125; else if (layer == self.layerView.layer) &#123;</div><div class="line">        [[[UIAlertView alloc] initWithTitle:@&quot;Inside White Layer&quot;</div><div class="line">                                    message:nil</div><div class="line">                                   delegate:nil</div><div class="line">                          cancelButtonTitle:@&quot;OK&quot;</div><div class="line">                          otherButtonTitles:nil] show];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 注意: 当调用图层的-hitTest:方法时，测算的顺序严格依赖于图层树当中的图层顺序（和UIView处理事件类似）。之前提到的zPosition属性可以明显改变屏幕上图层的顺序，但不能改变事件传递的顺序。<br> 这意味着如果改变了图层的z轴顺序，你会发现将不能够检测到最前方的视图点击事件，这是因为被另一个图层遮盖住了，虽然它的zPosition值较小，但是在图层树中的顺序靠前。</p>
<h1 id="自动布局"><a href="#自动布局" class="headerlink" title="自动布局"></a>自动布局</h1><p> 当使用视图的时候，可以充分利用UIView类接口暴露出来的<code>UIViewAutoresizingMask</code>和<code>NSLayoutConstraintAPI</code></p>
<h1 id="图像蒙版"><a href="#图像蒙版" class="headerlink" title="图像蒙版"></a>图像蒙版</h1><p> 通过masksToBounds属性，我们可以沿边界裁剪图形；通过cornerRadius属性，我们还可以设定一个圆角。但是有时候你希望展现的内容不是在一个矩形或圆角矩形<br> CALayer有一个属性叫做mask可以解决这个问题<br> 这个属性本身就是个CALayer类型，有和其他图层一样的绘制和布局属性。它类似于一个子图层，相对于父图层（即拥有该属性的图层）布局，但是它却不是一个普通的子图层。不同于那些绘制在父图层中的子图层，<code>图层定义了父图层的部分可见区域</code></p>
<p> 如果mask图层比父图层要小，只有在mask图层里面的内容才是它关心的，除此以外的一切都会被隐藏起来。<br> <img src="http://img.blog.csdn.net/20160106163641065" alt="这里写图片描述"></p>
<h1 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h1><p> “仿射”的意思是无论变换矩阵用什么值，图层中平行的两条线在变换之后任然保持平行</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CGAffineTransformMakeRotation(CGFloat angle)</div><div class="line">CGAffineTransformMakeScale(CGFloat sx, CGFloat sy)</div><div class="line">CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty)</div></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CGAffineTransform transform = CGAffineTransformMakeRotation(M_PI_4);</div><div class="line">   self.layerView.layer.affineTransform = transform;</div></pre></td></tr></table></figure>
<h1 id="3D变换"><a href="#3D变换" class="headerlink" title="3D变换"></a>3D变换</h1> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z)</div><div class="line">CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz) </div><div class="line">CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz)</div></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CATransform3D transform = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);</div><div class="line">self.layerView.layer.transform = transform;</div></pre></td></tr></table></figure>
<p> 参考: 本文是学习<a href="https://zsisme.gitbooks.io/ios-/content/index.html后进行的整理" target="_blank" rel="external">https://zsisme.gitbooks.io/ios-/content/index.html后进行的整理</a>, 更多详细的内容可以去看看</p>
<p> 原文链接: <a href="http://blog.csdn.net/zhz459880251/article/details/50470447" target="_blank" rel="external">http://blog.csdn.net/zhz459880251/article/details/50470447</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="zhzDeveloper.github.io/2016/01/06/CALayer 相关/" data-id="cj5d76fr10006fkhlngxazblh" class="article-share-link">分享</a><div class="tags"></div><div class="post-nav"><a href="/2016/01/06/CAGradientLayer,CAShapeLayer及UIBezierPath实现环形彩色进度条/" class="pre">CAGradientLayer,CAShapeLayer及UIBezierPath实现环形彩色进度条</a><a href="/2016/01/03/获取view的controller/" class="next">获取view的controller</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="zhzDeveloper.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS-分类/">iOS-分类</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios平台/">ios平台</a><span class="category-list-count">66</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios平台-UI控件/">ios平台,UI控件</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios平台-图片处理/">ios平台,图片处理</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios平台-开发工具/">ios平台,开发工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/swift/">swift</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发工具/">开发工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则/">正则</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机技巧/">计算机技巧</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/21/单元测试和集成测试/">单元测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/13/Python 爬虫初探/">Python 爬虫初探</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/12/数组排序sortedArrayUsingComparator/">数组排序sortedArrayUsingComparator</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/macOS Sierra 找回消失的 “任何来源”/">macOS Sierra 找回消失的 “任何来源”</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/11/Method Swizzling(转载+补充)/">Method Swizzling(转载+补充)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/10/instancesRespondToSelector与respondsToSelector的区别/">instancesRespondToSelector与respondsToSelector的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/08/生成Description/">生成Description</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/26/忽略编译警告/">忽略编译警告</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/09/iOS-面试题整理/">iOS-面试题整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/07/GCD小结/">GCD小结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">zhz blogs.</a> Powered by<a rel="nofollow" target="_blank" href="https://github.com/zhzDeveloper"> zhz.</a><a rel="nofollow" target="_blank" href="http://zhzdeveloper.github.io/"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/zhzDeveloper"> zhz.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>