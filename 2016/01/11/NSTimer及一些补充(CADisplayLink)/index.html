<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>NSTimer及一些补充(CADisplayLink) | zhz blogs</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">NSTimer及一些补充(CADisplayLink)</h1><a id="logo" href="/.">zhz blogs</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">NSTimer及一些补充(CADisplayLink)</h1><div class="post-meta">Jan 11, 2016<span> | </span><span class="category"><a href="/categories/ios平台/">ios平台</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"> <font color="blue" size="4"><br> 前面的部分是翻译的官方文档, 不当之处还请指出,<br> 后一部分则是对NSTimer的扩充, 及相关的CADisplayLink</font>

<p> <hr color="orange"></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p> 使用NSTimer能在给一个定的时间后发送一个消息给target<br> 一般NSTimer结合runloop工作,  所以为了能够正确地使用NSTimer, 有必要学习一下NSRunLoop 和  Threading Programming Guide(PS: 大致了解一下就行).<font color="red"> 特别注意: </font></p>
<blockquote>
<p>run loops maintain strong references to their timers, so you don’t have to maintain your own strong reference to a timer after you have added it to a run loop</p>
</blockquote>
<p> 也就是说 NSTimer创建时target的是强引用, 容易和控制器造成保留环(后面会重点了解)</p>
<p> 但是, 一个timer并不是一个严格的时间机制,  他的触发与所加入的RunLoop和RunLoop Mode有关，如果此RunLoop正在执行一个连续性的运算，timer就会被延时出发。重复性的timer遇到这种情况，如果延迟超过了一个周期，则会在延时结束后立刻执行，并按照之前指定的周期继续执行, 为了避免这种延时的发生一般设置时间间隔定时器仅限于在50 - 100毫秒之间.<br> 如果一个timer的触发时间发生在很长一段调出或在runloop模式(不是监视计时器)的话, 该计时器直到下一个runloop才会触发, 因此一个timer的触发时间可能会比预期的时间延时.<br> 这点也会在Timer Tolerance这节中见到.<br> <hr color="orange"></p>
<h1 id="重复-VS-不重复-计时器"><a href="#重复-VS-不重复-计时器" class="headerlink" title="重复 VS 不重复 计时器"></a>重复 VS 不重复 计时器</h1><p> non-repeating timer: 不重复计时器, 指一个计时器创建后只执行一次就invalidates销毁<br> repeating timer: 重复计时器, 指一个计时器创建执行一次后又重新放到相同的run loop中继续执行, 直到invalidates;</p>
 <hr color="orange">

<h1 id="时间容差-iOS7-0-and-later"><a href="#时间容差-iOS7-0-and-later" class="headerlink" title="时间容差(iOS7.0 and later)"></a>时间容差(iOS7.0 and later)</h1><p> 为了避免触发时间被错过, 你可以设置一个时间容差, 他可以根据系统的运行情况让timer的触发发生在规定的触发时间和(规定的触发时间+时间容差tolerance), <font color="red"> 特别注意: </font> 对于重复计时器来说, 他的下一次触发的时间是基于原始的触发时间, 而不会把tolerance计算在内的;<br> 时间容差的默认值是<font color="blue">0</font>;<br> 如果不设置的话, 或为0, 系统会自动设置一个很小的tolerance来优化性能,<br> 一般来说, 对于一个重复计时器, 设置一个大于等于interval * 10%的的tolerance是比较合理的;</p>
 <hr color="orange">

<h1 id="在runloop中设定计时器"><a href="#在runloop中设定计时器" class="headerlink" title="在runloop中设定计时器"></a>在runloop中设定计时器</h1><p> 尽管一个timer可以被添加到多个runloop内循环, 但是建议一个timer只放到一个runloop中;<br> 有3中方法创建一个timer:</p>
<ol>
<li><code>scheduledTimerWithTimeInterval:invocation:repeats:</code>或<br><code>scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</code><br>创建的计时器会被放到当前的runloop中 使用的是 default mode,  而不用手动放到runloop中</li>
<li><code>timerWithTimeInterval:invocation:repeats:</code>或<br><code>timerWithTimeInterval:target:selector:userInfo:repeats:</code><br>创建的计时器需要手动放到runloop中(使用 addTimer:forMode:)</li>
<li><p><code>initWithFireDate:interval:target:selector:userInfo:repeats:</code><br>创建的计时器需要手动放到runloop中(使用 addTimer:forMode:)</p>
<p>一个timer一旦放到runloop中, timer就会在规定的时间时触发, 直到timer失效. 一个不重复的timer被触发后会被立即invalidates, 不用在手动调用<code>[timer invalidate]</code>这个方法; 而对于一个重复timer来说, 你需要调用<code>[timer invalidate]</code>方法才会销毁, 从当前的runloop中移除;<br>总的来说, 当一个计时器不在使用时应当及时销毁, 防止影响当前runloop,  也防止保留环的出现<br>一个timer一旦invalidate销毁, 就不能再被使用.</p>
<p><font color="red">注意点:</font> 如果一个重复的timer调用完一个方法后, 超过了下一个触发时间点, 那么被超过的这个触发时间点不在触发, 而是直接跳到下一个触发点, 也就是说, 计时器不会试图弥补任何错过的指定的时间点调用指定的选择器或调用.<br>比如说, timer的action是- (void)test; TimeInterval是1s,  但是这个方法执行就需要1.5秒,  那么第二秒就会被舍弃, 不再执行, 直接执行第三秒<br>具体看事例: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line"></div><div class="line">    timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(test) userInfo:nil repeats:YES];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)test &#123;</div><div class="line">    </div><div class="line">    sleep(1);</div><div class="line">    NSDate *date = [NSDate date];</div><div class="line">    NSDateFormatter *format = [[NSDateFormatter alloc] init];</div><div class="line">    format.dateFormat = @&quot;HH:mm:ss.SSS&quot;;</div><div class="line">    self.showLable.text = [format stringFromDate:date];</div><div class="line">    NSLog(@&quot;--%@--&quot;, self.showLable.text);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">输出结果:</div><div class="line">2016-01-11 17:23:59.647 TestTimerStopAndStart[12208:299855] --17:23:59.647--</div><div class="line">2016-01-11 17:24:03.646 TestTimerStopAndStart[12208:299855] --17:24:03.646--</div><div class="line">2016-01-11 17:24:05.646 TestTimerStopAndStart[12208:299855] --17:24:05.646--</div></pre></td></tr></table></figure>
<p>可见中间都是差了一秒的, 也就是说本来应该被触发的那一秒没被触发, 跳过了;</p>
<hr color="orange">

</li>
</ol>
<h1 id="创建定时器"><a href="#创建定时器" class="headerlink" title="创建定时器"></a>创建定时器</h1><h2 id="1-scheduledTimerWithTimeInterval-invocation-repeats"><a href="#1-scheduledTimerWithTimeInterval-invocation-repeats" class="headerlink" title="1. + scheduledTimerWithTimeInterval:invocation:repeats:"></a>1. <code>+ scheduledTimerWithTimeInterval:invocation:repeats:</code></h2><p> 创建一个timer并添加到当前的runloop中,<br>         @param seconds : 如果设置的秒数小于等于0.0, 那么系统默认使用+0.1毫秒代替<br>         @param invocation: 当timer被触发时调用, invocation的参数都是强引用, timer被销毁时invocation也销毁<br>         @param repeats: 是否重复, YES重复, NO不重复</p>
<h2 id="2-scheduledTimerWithTimeInterval-target-selector-userInfo-repeats"><a href="#2-scheduledTimerWithTimeInterval-target-selector-userInfo-repeats" class="headerlink" title="2. + scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:"></a>2. <code>+ scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</code></h2><p> 创建一个timer并添加到当前的runloop中,<br>         @param seconds : 如果设置的秒数小于等于0.0, 那么系统默认使用+0.1毫秒代替<br>         @param target:  timer向target发送消息调用aselector方法,  timer一直对target执行强引用直到timer销毁;<br>         @param aselector: 发送给target的消息,<br>         @param userInfo: timer携带的信息,  也是请引用, 可以为nil<br>         @param repeats: 是否重复, YES重复, NO不重复</p>
<h2 id="3-timerWithTimeInterval-invocation-repeats"><a href="#3-timerWithTimeInterval-invocation-repeats" class="headerlink" title="3. + timerWithTimeInterval:invocation:repeats:"></a>3. <code>+ timerWithTimeInterval:invocation:repeats:</code></h2><p> 创建一个timer<font color="blue"> 但不会自动</font>添加到runloop中,<br>         @param seconds : 如果设置的秒数小于等于0.0, 那么系统默认使用+0.1毫秒代替<br>         @param invocation: 当timer被触发时调用, invocation的参数都是强引用, timer被销毁时invocation也销毁<br>         @param repeats: 是否重复, YES重复, NO不重复<br> 使用此方法, 必须手动添加到通过<code>addTimer:forMode:</code>得到的runloop中<br> 如果timer错过了触发点, 则会调用invocation, 如果定时器配置重复,没有必要随后重新添加计时器到runloop中</p>
<h2 id="4-timerWithTimeInterval-target-selector-userInfo-repeats"><a href="#4-timerWithTimeInterval-target-selector-userInfo-repeats" class="headerlink" title="4. + timerWithTimeInterval:target:selector:userInfo:repeats:"></a>4. <code>+ timerWithTimeInterval:target:selector:userInfo:repeats:</code></h2><p> 创建一个timer<font color="blue"> 但不会自动</font>添加到runloop中,<br>         @param seconds : 如果设置的秒数小于等于0.0, 那么系统默认使用+0.1毫秒代替<br>         @param target:  timer向target发送消息调用aselector方法,  timer一直对target执行强引用直到timer销毁;<br>         @param aselector: 发送给target的消息,<br>         @param userInfo: timer携带的信息,  也是请引用, 可以为nil<br>         @param repeats: 是否重复, YES重复, NO不重复<br>   使用此方法, 必须手动添加到通过<code>addTimer:forMode:</code>得到的runloop中</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSTimer *timer = [NSTimer timerWithTimeInterval:5 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];</div><div class="line"></div><div class="line">[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</div></pre></td></tr></table></figure>
<h2 id="5-initWithFireDate-interval-target-selector-userInfo-repeats"><a href="#5-initWithFireDate-interval-target-selector-userInfo-repeats" class="headerlink" title="5. - initWithFireDate:interval:target:selector:userInfo:repeats:"></a>5. <code>- initWithFireDate:interval:target:selector:userInfo:repeats:</code></h2><p> 创建一个timer<font color="blue"> 但不会自动</font>添加到runloop中,<br>         @param date :timer第一次被触发时间<br>         @param seconds : 如果设置的秒数小于等于0.0, 那么系统默认使用+0.1毫秒代替<br>         @param target:  timer向target发送消息调用aselector方法,  timer一直对target执行强引用直到timer销毁;<br>         @param aselector: 发送给target的消息,<br>         @param userInfo: timer携带的信息,  也是请引用, 可以为nil<br>         @param repeats: 是否重复, YES重复, NO不重复<br>   使用此方法, 必须手动添加到通过<code>addTimer:forMode:</code>得到的runloop中</p>
 <hr color="orange">

<h1 id="启动定时器"><a href="#启动定时器" class="headerlink" title="启动定时器"></a>启动定时器</h1><p> <font color="blue" size="9"> fire</font><br> 触发timer<br> 如果是重复的timer, 他不会打断正常的触发<br> 如果是不重复的timer, 则会提前触发timer, 即使还没到计划的时间</p>
 <hr color="orange">

<h1 id="停止定时器"><a href="#停止定时器" class="headerlink" title="停止定时器"></a>停止定时器</h1><p> <font color="blue" size="9"> invalidate</font><br> 是唯一个从runloop中移除计时器的方法, NSRunloop移除对timer的强引用,  并且timer的参数也移除对他参数的移除<br> <hr color="orange"></p>
<h1 id="对计时器的控制"><a href="#对计时器的控制" class="headerlink" title="对计时器的控制"></a>对计时器的控制</h1> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[timer setFireDate:[NSDate date]]; //继续。</div><div class="line">[timer setFireDate:[NSDate distantPast]];//开启</div><div class="line">[timer setFireDate:[NSDate distantFuture]];//暂停</div></pre></td></tr></table></figure>
 <hr color="orange">

<h1 id="NSTimer-分类"><a href="#NSTimer-分类" class="headerlink" title="NSTimer 分类"></a>NSTimer 分类</h1> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">///计时器 暂停</div><div class="line">- (void)pauseTimer;</div><div class="line"></div><div class="line">///计时器 恢复</div><div class="line">- (void)resumeTimer;</div><div class="line"></div><div class="line">///计时器 先暂停, 再间隔n秒后恢复计时</div><div class="line">- (void)resumeTimerAfterTimeInterval:(NSTimeInterval)interval;</div></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@implementation NSTimer (Addition)</div><div class="line"></div><div class="line">- (void)pauseTimer &#123;</div><div class="line">    if (![self isValid]) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    [self setFireDate:[NSDate distantFuture]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)resumeTimer &#123;</div><div class="line">    if (![self isValid]) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    [self setFireDate:[NSDate date]];</div><div class="line">    //或者[self setFireDate:[NSDate distantPast]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)resumeTimerAfterTimeInterval:(NSTimeInterval)interval &#123;</div><div class="line">    if (![self isValid]) &#123;</div><div class="line">        return ;</div><div class="line">    &#125;</div><div class="line">    [self setFireDate:[NSDate dateWithTimeIntervalSinceNow:interval]];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <hr color="orange"><br> </p><h1>补充(CADisplayLink)</h1><p></p>
 <hr color="orange">

<p> 使用NSTimer总会遇到被错过的触发点, 另一个关于时间的类是CADisplayLink</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(handleDisplayLink:)];    </div><div class="line"></div><div class="line">[self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</div></pre></td></tr></table></figure>
<h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">self.displayLink invalidate];  </div><div class="line"></div><div class="line">self.displayLink = nil;</div><div class="line">/**当把CADisplayLink对象add到runloop中后，selector就能被周期性调用，类似于重复的NSTimer被启动了；执行invalidate操作时，CADisplayLink对象就会从runloop中移除，selector调用也随即停止，类似于NSTimer的invalidate方法。**/</div></pre></td></tr></table></figure>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="1-屏幕刷新时调用"><a href="#1-屏幕刷新时调用" class="headerlink" title="1. 屏幕刷新时调用"></a>1. 屏幕刷新时调用</h3><p> CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。CADisplayLink以特定模式注册到runloop后，每当屏幕显示内容刷新结束的时候，runloop就会向CADisplayLink指定的target发送一次指定的selector消息， CADisplayLink类对应的selector就会被调用一次。所以通常情况下，按照iOS设备屏幕的刷新率60次/秒</p>
<h3 id="2-延迟"><a href="#2-延迟" class="headerlink" title="2. 延迟"></a>2. 延迟</h3><p> iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。但如果调用的方法比较耗时，超过了屏幕刷新周期，就会导致跳过若干次回调调用机会。<br> 如果CPU过于繁忙，无法保证屏幕60次/秒的刷新率，就会导致跳过若干次调用回调方法的机会，跳过次数取决CPU的忙碌程度。</p>
<h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h3><p> 从原理上可以看出，CADisplayLink适合做界面的不停重绘，比如视频播放的时候需要不停地获取下一帧用于界面渲染。</p>
<h3 id="4-重要属性"><a href="#4-重要属性" class="headerlink" title="4. 重要属性"></a>4. 重要属性</h3><p> <font color="blue" size="4"> frameInterval</font><br> NSInteger类型的值，用来设置间隔多少帧调用一次selector方法，默认值是1，即每帧都调用一次。</p>
<p> <font color="blue" size="4"> duration</font><br> readOnly的CFTimeInterval值，表示两次屏幕刷新之间的时间间隔。需要注意的是，该属性在target的selector被首次调用以后才会被赋值。selector的调用间隔时间计算方式是：调用间隔时间 = duration × frameInterval。<br> <hr color="orange"></p>
<p> <font color="red" size="6">特别注意</font>:<br> 当tableView的每个cell都有一个timer, 滑动时会卡顿, 是因为 RunLoop 的 Mode 原因，你把 timer 加入到 Runloop 中的 NSRunLoopCommonMode 就可以了。<br> 就是这一句：<code>[[NSRunLoop mainRunLoop] addTimer:timer forMode: NSRunLoopCommonMode]</code>;</p>
 <hr color="orange">

<p> 参考: </p>
<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/</a></li>
<li><p><a href="http://www.jianshu.com/p/21d351116587" target="_blank" rel="external">http://www.jianshu.com/p/21d351116587</a></p>
<p>原文链接: <a href="http://blog.csdn.net/zhz459880251/article/details/50498854" target="_blank" rel="external">http://blog.csdn.net/zhz459880251/article/details/50498854</a></p>
</li>
</ol>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="zhzDeveloper.github.io/2016/01/11/NSTimer及一些补充(CADisplayLink)/" data-id="cj7rl7qmp000zwghlv6aygnbu" class="article-share-link">分享</a><div class="tags"></div><div class="post-nav"><a href="/2016/01/20/Mac和 iOS下的对称和非对称加密算法的使用/" class="pre">Mac和 iOS下的对称和非对称加密算法的使用</a><a href="/2016/01/07/NSString 与 Class 互转/" class="next">NSString 与 Class 互转</a></div><div id="uyan_frame"></div><script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2144959"></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="zhzDeveloper.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS-分类/">iOS-分类</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios平台/">ios平台</a><span class="category-list-count">66</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios平台-UI控件/">ios平台,UI控件</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios平台-图片处理/">ios平台,图片处理</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios平台-开发工具/">ios平台,开发工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/swift/">swift</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发工具/">开发工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则/">正则</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机技巧/">计算机技巧</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/21/单元测试和集成测试/">单元测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/13/Python 爬虫初探/">Python 爬虫初探</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/12/数组排序sortedArrayUsingComparator/">数组排序sortedArrayUsingComparator</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/macOS Sierra 找回消失的 “任何来源”/">macOS Sierra 找回消失的 “任何来源”</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/11/Method Swizzling(转载+补充)/">Method Swizzling(转载+补充)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/10/instancesRespondToSelector与respondsToSelector的区别/">instancesRespondToSelector与respondsToSelector的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/08/生成Description/">生成Description</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/26/忽略编译警告/">忽略编译警告</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/09/iOS-面试题整理/">iOS-面试题整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/07/GCD小结/">GCD小结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/zhzDeveloper/" title="github" target="_blank">github</a><ul></ul><a href="http://blog.csdn.net/zhz459880251" title="blogs" target="_blank">blogs</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">zhz blogs.</a> Powered by<a rel="nofollow" target="_blank" href="https://github.com/zhzDeveloper"> zhz.</a><a rel="nofollow" target="_blank" href="http://zhzdeveloper.github.io/"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/zhzDeveloper"> zhz.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>