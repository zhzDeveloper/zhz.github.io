<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS-面试题整理 | zhz blogs</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS-面试题整理</h1><a id="logo" href="/.">zhz blogs</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS-面试题整理</h1><div class="post-meta">Apr 9, 2016<span> | </span><span class="category"><a href="/categories/ios平台/">ios平台</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h1 id="【※】-property中有哪些属性关键字？"><a href="#【※】-property中有哪些属性关键字？" class="headerlink" title="【※】@property中有哪些属性关键字？"></a>【※】@property中有哪些属性关键字？</h1><hr>
<h2 id="访问控制组"><a href="#访问控制组" class="headerlink" title="访问控制组"></a>访问控制组</h2><ol>
<li>nonatomic</li>
<li>atomic<h2 id="内存管理组"><a href="#内存管理组" class="headerlink" title="内存管理组"></a>内存管理组</h2></li>
<li>weak</li>
<li>strong</li>
<li>copy<h2 id="读写组"><a href="#读写组" class="headerlink" title="读写组"></a>读写组</h2></li>
<li>readwrite</li>
<li>readonly<h2 id="重命名组"><a href="#重命名组" class="headerlink" title="重命名组"></a>重命名组</h2></li>
<li>getter</li>
<li>setter</li>
</ol>
<h1 id="【※】weak属性需要在dealloc中置nil么？"><a href="#【※】weak属性需要在dealloc中置nil么？" class="headerlink" title="【※】weak属性需要在dealloc中置nil么？"></a>【※】weak属性需要在dealloc中置nil么？</h1><hr>
<p> 不需要, 使用weak修饰的属性, 会在RC从1变为0的时候自动销毁,并置为nil</p>
<h1 id="【※※】-synthesize和-dynamic分别有什么作用？"><a href="#【※※】-synthesize和-dynamic分别有什么作用？" class="headerlink" title="【※※】@synthesize和@dynamic分别有什么作用？"></a>【※※】@synthesize和@dynamic分别有什么作用？</h1><hr>
<p> 首先两者都是用在.m文件中的<br> @synthesize<br> 系统自动生成getter和setter方法, 不需要程序员去写, 如果有需求要<code>同时</code>重写使用@property生成的实例变量的setter和getter方法, 这必须添加<code>@synthesize 声明的属性 = 变量</code><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@synthesize name = _name;</div></pre></td></tr></table></figure></p>
<p> @dynamic<br> 属性的setter和getter方法需要程序员自己生成</p>
<h1 id="【※※※】ARC下，不显示指定任何属性关键字时，默认的关键字都有哪些？"><a href="#【※※※】ARC下，不显示指定任何属性关键字时，默认的关键字都有哪些？" class="headerlink" title="【※※※】ARC下，不显示指定任何属性关键字时，默认的关键字都有哪些？"></a>【※※※】ARC下，不显示指定任何属性关键字时，默认的关键字都有哪些？</h1><hr>
<ol>
<li><p>对应基本数据类型默认关键字是<br>atomic, readwrite, assign</p>
</li>
<li><p>对于普通的OC对象<br>atomic, readwrite, strong</p>
</li>
</ol>
<h1 id="【※※※】用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"><a href="#【※※※】用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？" class="headerlink" title="【※※※】用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"></a>【※※※】用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h1><hr>
<p> 首先NSString, NSArray, NSDictionary都有可变的子类, 当使用NSString声明的属性, 被其子类NSMutableString赋值时, 其实只是把该属性的指针指向了NSMutableString对象, 那么改变NSMutableString的值, NSString修饰的属性值也会改变<br> <img src="http://img.blog.csdn.net/20160405111328656" alt="这里写图片描述"><br> ….<br> name使用copy修饰<br> <img src="http://img.blog.csdn.net/20160405111412437" alt="这里写图片描述"></p>
<h1 id="【※※※】-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？"><a href="#【※※※】-synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为-foo的实例变量，那么还会自动合成新变量么？" class="headerlink" title="【※※※】@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？"></a>【※※※】@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？</h1><hr>
<p> @synthesize合成实例变量的规则</p>
<ol>
<li>如果手动实现了set方法，那么编译器就只生成get方法和成员变量；</li>
<li>如果手动实现了get方法，那么编译器就只生成set方法和成员变量；</li>
<li><p>如果set和get方法都是手动实现的，那么编译器将不会生成成员变量</p>
<p>假如property名为foo，存在一个名为_foo的实例变量，是不会合成新变量的</p>
<p><img src="http://img.blog.csdn.net/20160405114811919" alt="这里写图片描述"></p>
<p>使用运行时获取成员变量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">1、获取某个类的成员变量或属性；</div><div class="line"></div><div class="line"></div><div class="line">unsigned int numIvars; //成员变量个数</div><div class="line">    Ivar *vars = class_copyIvarList(NSClassFromString(@&quot;Person&quot;), &amp;numIvars);</div><div class="line">    </div><div class="line">    NSString *key=nil;</div><div class="line">    for(int i = 0; i &lt; numIvars; i++) &#123;</div><div class="line"></div><div class="line">        Ivar thisIvar = vars[i];</div><div class="line">        key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];  //获取成员变量的名字</div><div class="line">        NSLog(@&quot;variable name :%@&quot;, key);</div><div class="line">        key = [NSString stringWithUTF8String:ivar_getTypeEncoding(thisIvar)]; //获取成员变量的数据类型</div><div class="line">        NSLog(@&quot;variable type :%@&quot;, key);</div><div class="line">    &#125;</div><div class="line">    free(vars);</div><div class="line"></div><div class="line"></div><div class="line">2、获取成员函数</div><div class="line">    Method *meth = class_copyMethodList(NSClassFromString(@&quot;Person&quot;), &amp;numIvars);</div><div class="line">    </div><div class="line">    for(int i = 0; i &lt; numIvars; i++) &#123;</div><div class="line">        Method thisIvar = meth[i];</div><div class="line">        </div><div class="line">        SEL sel = method_getName(thisIvar);</div><div class="line">        const char *name = sel_getName(sel);</div><div class="line">        </div><div class="line">        NSLog(@&quot;zp method :%s&quot;, name);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    free(meth);</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="【※※※※※】在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？"><a href="#【※※※※※】在有了自动合成属性实例变量之后，-synthesize还有哪些使用场景？" class="headerlink" title="【※※※※※】在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？"></a>【※※※※※】在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？</h1><hr>
<p> 在声明属性@property的情况下如果重写setter,getter,方法，就需要把未识别的变量在@synthesize中定义，把属性的存取方法作用于变量。<code>@synthesize 声明的属性 = 变量</code></p>
<h1 id="【※※】objc中向一个nil对象发送消息将会发生什么？"><a href="#【※※】objc中向一个nil对象发送消息将会发生什么？" class="headerlink" title="【※※】objc中向一个nil对象发送消息将会发生什么？"></a>【※※】objc中向一个nil对象发送消息将会发生什么？</h1><hr>
<p> 在Objective-C中向nil发送消息是完全有效的——只是在运行时不会有任何作用:</p>
<p> 如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。例如：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person * motherInlaw = [[aPerson spouse] mother];</div></pre></td></tr></table></figure></p>
<p> 如果spouse对象为nil，那么发送给nil的消息mother也将返回nil。</p>
<p> 1）如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者long long的整型标量，发送给nil的消息将返回0。</p>
<p> 2）如果方法返回值为结构体,发送给nil的消息将返回0。结构体中各个字段的值将都是0。</p>
<p> 3）如果方法的返回值不是上述提到的几种情况，那么发送给nil的消息的返回值将是未定义的。</p>
<h1 id="【※※※】objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？"><a href="#【※※※】objc中向一个对象发送消息-obj-foo-和objc-msgSend-函数之间有什么关系？" class="headerlink" title="【※※※】objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？"></a>【※※※】objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</h1><hr>
<p> [receiver message]会被编译器转化为：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector)</div></pre></td></tr></table></figure></p>
<p> 如果消息含有参数，则为：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</div></pre></td></tr></table></figure></p>
<p> 如果消息的接收者能够找到对应的selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个selector对应的实现内容，要么就干脆崩溃掉。</p>
<h1 id="【※※※】什么时候会报unrecognized-selector的异常？"><a href="#【※※※】什么时候会报unrecognized-selector的异常？" class="headerlink" title="【※※※】什么时候会报unrecognized selector的异常？"></a>【※※※】什么时候会报unrecognized selector的异常？</h1><hr>
<p> 使用方法选择器<code>@selector(方法名)</code>调用方法时方法未被实现; 在编译时不会报错, 在运行时则会崩溃, 这就是OC的运行时机制</p>
<h1 id="【※※※※】一个objc对象如何进行内存布局？（考虑有父类的情况）"><a href="#【※※※※】一个objc对象如何进行内存布局？（考虑有父类的情况）" class="headerlink" title="【※※※※】一个objc对象如何进行内存布局？（考虑有父类的情况）"></a>【※※※※】一个objc对象如何进行内存布局？（考虑有父类的情况）</h1><hr>
<ol>
<li><p>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.</p>
</li>
<li><p>每一个对象内部都有一个isa指针, 指向他的类对象, 类对象中存放着本对象的<br>1）对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中<br>2）成员变量的列表<br>3）属性列表</p>
</li>
</ol>
<h1 id="【※※※※】一个objc对象的isa的指针指向什么？有什么作用？"><a href="#【※※※※】一个objc对象的isa的指针指向什么？有什么作用？" class="headerlink" title="【※※※※】一个objc对象的isa的指针指向什么？有什么作用？"></a>【※※※※】一个objc对象的isa的指针指向什么？有什么作用？</h1><hr>
<p> 指向他的类对象, 从而可以找到对象上的方法<br> 类对象中存放着本对象的<br>     1）对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中<br>     2）成员变量的列表<br>     3）属性列表</p>
<h1 id="【※※※※】下面的代码输出什么？"><a href="#【※※※※】下面的代码输出什么？" class="headerlink" title="【※※※※】下面的代码输出什么？"></a>【※※※※】下面的代码输出什么？</h1> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@implementation Son : Father</div><div class="line">- (id)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));</div><div class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p> 输出的结果都是:Son,<br> 原因:<br> super 和 self 都是指向的本实例对象的,<br> 不同的是, super调用的跳过本类方法,调用父类的方法<br> 父类方法的class方法本来都是在基类中实现的,所以无论使用self和super调用都是一样的.</p>
<p> 上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son ＊xxx 这个对象。而不同的是，<code>super是告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的</code>。</p>
<h1 id="【※※※※】runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）"><a href="#【※※※※】runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）" class="headerlink" title="【※※※※】runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）"></a>【※※※※】runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h1><hr>
<p> 每一个类对象中都一个方法列表,方法列表中记录着方法的名称, 方法实现, 以及参数类型, 其实selector本质就是方法名称, 通过这个方法名称就可以在方法列表中找到对应的方法实现.</p>
<h1 id="【※※※※※】objc中的类方法和实例方法有什么本质区别和联系？"><a href="#【※※※※※】objc中的类方法和实例方法有什么本质区别和联系？" class="headerlink" title="【※※※※※】objc中的类方法和实例方法有什么本质区别和联系？"></a>【※※※※※】objc中的类方法和实例方法有什么本质区别和联系？</h1><hr>
<ul>
<li>类方法<br>类方法是属于类对象的<br>类方法只能通过类对象调用<br>类方法中的self是类对象<br>类方法可以调用其他的类方法<br>类方法中不能访问成员变量<br>类方法中不定直接调用对象方法</li>
<li>实例方法<br>实例方法是属于实例对象的<br>实例方法只能通过实例对象调用<br>实例方法中的self是实例对象<br>实例方法中可以访问成员变量<br>实例方法中直接调用实例方法<br>实例方法中也可以调用类方法(通过类名)</li>
</ul>
<h1 id="【※※※※※】runtime如何实现weak变量的自动置nil？"><a href="#【※※※※※】runtime如何实现weak变量的自动置nil？" class="headerlink" title="【※※※※※】runtime如何实现weak变量的自动置nil？"></a>【※※※※※】runtime如何实现weak变量的自动置nil？</h1><hr>
<p> 要实现weak属性，首先要搞清楚weak属性的特点：</p>
<p> weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。</p>
<p> 那么runtime如何实现weak变量的自动置nil？</p>
<p> runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p>
<h1 id="【※※※※※】能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"><a href="#【※※※※※】能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？" class="headerlink" title="【※※※※※】能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"></a>【※※※※※】能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h1><hr>
<ol>
<li>不能向编译后得到的类中增加实例变量；</li>
<li><p>能向运行时创建的类中添加实例变量；</p>
<p>解释下：</p>
<p>因为编译后的类已经注册在 runtime 中，类结构体中的 objc_ivar_list 实例变量的链表 和 instance_size 实例变量的内存大小已经确定，同时runtime 会调用 class_setIvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；</p>
<p>运行时创建的类是可以添加实例变量，调用 class_addIvar 函数。但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。</p>
</li>
</ol>
<h1 id="【※※※】runloop和线程有什么关系？"><a href="#【※※※】runloop和线程有什么关系？" class="headerlink" title="【※※※】runloop和线程有什么关系？"></a>【※※※】runloop和线程有什么关系？</h1><hr>
<p> run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程的基础架构部分， Cocoa 和 CoreFundation 都提供了 run loop 对象方便配置和管理线程的 run loop （以下都以 Cocoa 为例）。每个线程，包括程序的主线程（ main thread ）都有与之相应的 run loop 对象。</p>
<p> runloop 和线程的关系：</p>
<ol>
<li><p>主线程的run loop默认是启动的。</p>
<p>iOS的应用程序里面，程序启动后会有一个如下的main()函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">@autoreleasepool &#123;</div><div class="line">    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。</p>
</li>
<li><p>对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。</p>
<p>在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop 。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSRunLoop</span> *runloop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="【※※※】runloop的mode作用是什么？"><a href="#【※※※】runloop的mode作用是什么？" class="headerlink" title="【※※※】runloop的mode作用是什么？"></a>【※※※】runloop的mode作用是什么？</h1><hr>
<p> model 主要是用来指定事件在运行循环中的优先级的，分为：</p>
<blockquote>
<p>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态<br> UITrackingRunLoopMode：ScrollView滑动时<br> UIInitializationRunLoopMode：启动时<br> NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合</p>
</blockquote>
<p> 苹果公开提供的 Mode 有两个：</p>
<blockquote>
<p>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）<br> NSRunLoopCommonModes（kCFRunLoopCommonModes）</p>
</blockquote>
<h1 id="【※※※※】以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"><a href="#【※※※※】以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？" class="headerlink" title="【※※※※】以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"></a>【※※※※】以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h1><hr>
<p> RunLoop只能运行在一种mode下，如果要换mode，当前的loop也需要停下重启成新的。利用这个机制，ScrollView滚动过程中NSDefaultRunLoopMode（kCFRunLoopDefaultMode）的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动：只能在NSDefaultRunLoopMode模式下处理的事件会影响ScrollView的滑动。</p>
<p> 如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。</p>
<p> 同时因为mode还是可定制的，所以：</p>
<p> Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes（kCFRunLoopCommonModes）来解决</p>
<h1 id="【※※※】对于Run-Loop的理解"><a href="#【※※※】对于Run-Loop的理解" class="headerlink" title="【※※※】对于Run Loop的理解"></a>【※※※】对于Run Loop的理解</h1><hr>
 <big><em> RunLoop，是多线程的法宝，即一个线程一次只能执行一个任务，执行完任务后就会退出线程。主线程执行完即时任务时会继续等待接收事件而不退出。非主线程通常来说就是为了执行某一任务的，执行完毕就需要归还资源，因此默认是不运行RunLoop的；
 </em> 每一个线程都有其对应的RunLoop，只是默认只有主线程的RunLoop是启动的，其它子线程的RunLoop默认是不启动的，若要启动则需要手动启动；<br> <em> 在一个单独的线程中，如果需要在处理完某个任务后不退出，继续等待接收事件，则需要启用RunLoop；
 </em> NSRunLoop提供了一个添加NSTimer的方法，可以指定Mode，如果要让任何情况下都回调，则需要设置Mode为Common模式；<br> * 实质上，对于子线程的runloop默认是不存在的，因为苹果采用了懒加载的方式。如果我们没有手动调用[NSRunLoop currentRunLoop]的话，就不会去查询是否存在当前线程的RunLoop，也就不会去加载，更不会创建。</big>

<h1 id="【※】objc使用什么机制管理对象内存？"><a href="#【※】objc使用什么机制管理对象内存？" class="headerlink" title="【※】objc使用什么机制管理对象内存？"></a>【※】objc使用什么机制管理对象内存？</h1><hr>
<p> 通过 retainCount 的机制来决定对象是否需要释放。 每次 runloop 的时候，都会检查对象的 retainCount，如果retainCount 为 0，说明该对象没有地方需要继续使用了，可以释放掉了。</p>
<h1 id="【※※※※】BAD-ACCESS在什么情况下出现？"><a href="#【※※※※】BAD-ACCESS在什么情况下出现？" class="headerlink" title="【※※※※】BAD_ACCESS在什么情况下出现？"></a>【※※※※】BAD_ACCESS在什么情况下出现？</h1><hr>
<ol>
<li>死循环</li>
<li>访问一个僵尸对象</li>
</ol>
<h1 id="【※※】使用block时什么情况会发生引用循环，如何解决？"><a href="#【※※】使用block时什么情况会发生引用循环，如何解决？" class="headerlink" title="【※※】使用block时什么情况会发生引用循环，如何解决？"></a>【※※】使用block时什么情况会发生引用循环，如何解决？</h1><h1 id="【※※】在block内如何修改block外部变量？"><a href="#【※※】在block内如何修改block外部变量？" class="headerlink" title="【※※】在block内如何修改block外部变量？"></a>【※※】在block内如何修改block外部变量？</h1><h1 id="【※※※】使用系统的某些block-api（如UIView的block版本写动画时），是否也考虑引用循环问题？"><a href="#【※※※】使用系统的某些block-api（如UIView的block版本写动画时），是否也考虑引用循环问题？" class="headerlink" title="【※※※】使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？"></a>【※※※】使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？</h1><hr>
<p> 以上三题<br> 参考: <a href="http://blog.csdn.net/zhz459880251/article/details/50881086" target="_blank" rel="external">http://blog.csdn.net/zhz459880251/article/details/50881086</a></p>
<h1 id="【※※】GCD的队列（dispatch-queue-t）分哪两种类型？"><a href="#【※※】GCD的队列（dispatch-queue-t）分哪两种类型？" class="headerlink" title="【※※】GCD的队列（dispatch_queue_t）分哪两种类型？"></a>【※※】GCD的队列（dispatch_queue_t）分哪两种类型？</h1><hr>
<ol>
<li>串行队列Serial Dispatch Queue</li>
<li>并行队列Concurrent Dispatch Queue</li>
</ol>
<h1 id="【※※※※】如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）"><a href="#【※※※※】如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）" class="headerlink" title="【※※※※】如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）"></a>【※※※※】如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</h1><hr>
<p> 使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_async(group, queue, ^&#123; /*加载图片1 */ &#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123; /*加载图片2 */ &#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123; /*加载图片3 */ &#125;); </div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">        // 合并图片</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="【※※※※】dispatch-barrier-async的作用是什么？"><a href="#【※※※※】dispatch-barrier-async的作用是什么？" class="headerlink" title="【※※※※】dispatch_barrier_async的作用是什么？"></a>【※※※※】dispatch_barrier_async的作用是什么？</h1><hr>
<p> 在并行队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用 barrier 来等待之前任务完成，避免数据竞争等问题。 dispatch_barrier_async 函数会等待追加到Concurrent Dispatch Queue并行队列中的操作全部执行完之后，然后再执行 dispatch_barrier_async 函数追加的处理，等 dispatch_barrier_async 追加的处理执行结束之后，Concurrent Dispatch Queue才恢复之前的动作继续执行。<br> （注意：使用 dispatch_barrier_async ，该函数只能搭配自定义并行队列 dispatch_queue_t 使用。不能使用： dispatch_get_global_queue ，否则 dispatch_barrier_async 的作用会和 dispatch_async 的作用一模一样。 ）</p>
<h1 id="【※※※※※】苹果为什么要废弃dispatch-get-current-queue？"><a href="#【※※※※※】苹果为什么要废弃dispatch-get-current-queue？" class="headerlink" title="【※※※※※】苹果为什么要废弃dispatch_get_current_queue？"></a>【※※※※※】苹果为什么要废弃dispatch_get_current_queue？</h1><hr>
<p> 容易误用造成死锁</p>
<h1 id="【※※※※※】以下代码运行结果如何？"><a href="#【※※※※※】以下代码运行结果如何？" class="headerlink" title="【※※※※※】以下代码运行结果如何？"></a>【※※※※※】以下代码运行结果如何？</h1> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    NSLog(@&quot;1&quot;);</div><div class="line">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;2&quot;);</div><div class="line">    &#125;);</div><div class="line">    NSLog(@&quot;3&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p> 只输出：1  发生主线程锁死。</p>
<h1 id="【※※】addObserver-forKeyPath-options-context-各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？"><a href="#【※※】addObserver-forKeyPath-options-context-各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？" class="headerlink" title="【※※】addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？"></a>【※※】addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</h1><hr>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">1 观察者，负责处理监听事件的对象</div><div class="line">2 观察的属性</div><div class="line">3 观察的选项</div><div class="line">4 上下文</div><div class="line">*/</div><div class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@&quot;Person Name&quot;];</div></pre></td></tr></table></figure>
<p> observer中需要实现一下方法：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 所有的 kvo 监听到事件，都会调用此方法</div><div class="line">/*</div><div class="line"> 1. 观察的属性</div><div class="line"> 2. 观察的对象</div><div class="line"> 3. change 属性变化字典（新／旧）</div><div class="line"> 4. 上下文，与监听的时候传递的一致</div><div class="line"> */</div><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;</div></pre></td></tr></table></figure></p>
<h1 id="【※※※】如何手动触发一个value的KVO"><a href="#【※※※】如何手动触发一个value的KVO" class="headerlink" title="【※※※】如何手动触发一个value的KVO"></a>【※※※】如何手动触发一个value的KVO</h1><hr>
<blockquote>
<ul>
<li>手动触发: <pre><code>调用willChangeValueForKey: 和 didChangevlueForKey: 方法
</code></pre><ul>
<li>自动触发:<br>   调用setter方法    </li>
</ul>
</li>
</ul>
</blockquote>
<p> 自动触发是指类似这种场景：在注册 KVO 之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了。</p>
<p> 想知道如何手动触发，必须知道自动触发 KVO 的原理：</p>
<blockquote>
<p>键值观察通知依赖于 NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey: 。在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就会记录旧的值。而当改变发生后， didChangeValueForKey: 会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了。</p>
</blockquote>
<p> 那么“手动触发”的使用场景是什么？一般我们只在希望能控制<code>回调的调用时机</code>时才会这么做。</p>
<p> 具体做法如下：</p>
<p> 如果这个 value 是 表示时间的 self.now ，那么代码如下：最后两行代码缺一不可。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//@property (nonatomic, strong) NSDate *now;</div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    [self willChangeValueForKey:@&quot;now&quot;]; // “手动触发self.now的KVO”，必写。</div><div class="line">    [self didChangeValueForKey:@&quot;now&quot;]; // “手动触发self.now的KVO”，必写。</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 但是平时我们一般不会这么干，我们都是等系统去“自动触发”。“自动触发”的实现原理：</p>
<blockquote>
<p>比如调用 setNow: 时，系统还会以某种方式在中间插入 wilChangeValueForKey: 、 didChangeValueForKey: 和 observeValueForKeyPath:ofObject:change:context: 的调用。</p>
</blockquote>
<p> 大家可能以为这是因为 setNow: 是合成方法，有时候我们也能看到人们这么写代码:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)setNow:(NSDate *)aDate &#123;</div><div class="line">    [self willChangeValueForKey:@&quot;now&quot;]; // 没有必要</div><div class="line">    _now = aDate;</div><div class="line">    [self didChangeValueForKey:@&quot;now&quot;];// 没有必要</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 这是完全没有必要的代码，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用 willChangeValueForKey: ，之后总是调用 didChangeValueForkey: 。</p>
<h1 id="【※※※】若一个类有实例变量NSString-foo，调用setValue-forKey-时，可以以foo还是-foo作为key？"><a href="#【※※※】若一个类有实例变量NSString-foo，调用setValue-forKey-时，可以以foo还是-foo作为key？" class="headerlink" title="【※※※】若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？"></a>【※※※】若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？</h1><hr>
<p> 都可以, 先查找_foo, 如果没有再查找foo, 如果都没有则调用<br> <code>setValue:forUndefinedKey:</code></p>
<h1 id="【※※※※】KVC的keyPath中的集合运算符如何使用？"><a href="#【※※※※】KVC的keyPath中的集合运算符如何使用？" class="headerlink" title="【※※※※】KVC的keyPath中的集合运算符如何使用？"></a>【※※※※】KVC的keyPath中的集合运算符如何使用？</h1><hr>
<ol>
<li>必须用在集合对象上或普通对象的集合属性上</li>
<li>简单集合运算符有@avg， @count ， @max ， @min ，@sum</li>
<li>格式 @”<code>@sum.age</code>“或 @”<code>集合属性.@max.age</code>“</li>
</ol>
<h1 id="【※※※※】KVC和KVO的keyPath一定是属性么？"><a href="#【※※※※】KVC和KVO的keyPath一定是属性么？" class="headerlink" title="【※※※※】KVC和KVO的keyPath一定是属性么？"></a>【※※※※】KVC和KVO的keyPath一定是属性么？</h1><hr>
<p> KVO支持实例变量, 不通过调用setter, getter方法, 间接赋值取值</p>
<h1 id="【※※※※※】如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？"><a href="#【※※※※※】如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？" class="headerlink" title="【※※※※※】如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？"></a>【※※※※※】如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？</h1><hr>
<p> 简单概述下 KVO 的实现：</p>
<p> 当你观察一个对象时，一个新的类会动态被创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。自然，重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象值的更改。最后把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。</p>
<p> 原来，这个中间类，继承自原本的那个类。不仅如此，Apple 还重写了 -class 方法，企图欺骗我们这个类没有变，就是原本那个类。更具体的信息，去跑一下 Mike Ash 的那篇文章里的代码就能明白，这里就不再重复。<br> <a href="http://tech.glowing.com/cn/implement-kvo/" target="_blank" rel="external">如何自己动手实现 KVO</a></p>
<h1 id="【※※※※※】apple用什么方式实现对一个对象的KVO？"><a href="#【※※※※※】apple用什么方式实现对一个对象的KVO？" class="headerlink" title="【※※※※※】apple用什么方式实现对一个对象的KVO？"></a>【※※※※※】apple用什么方式实现对一个对象的KVO？</h1><hr>
<p> KVO 在实现中通过<code>isa 混写（isa-swizzling）</code> 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向一个个新创建的子类，对象就神奇的变成了新创建的子类的实例。这在Apple 的文档可以得到印证：</p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class …</p>
</blockquote>
<p> 假设“被监听的对象”的类对象是 MYClass ，有时候我们能看到对 NSKVONotifying_MYClass 的引用而不是对 MYClass 的引用。借此我们得以知道 Apple 使用了<code>isa 混写（isa-swizzling）</code>。</p>
<h1 id="【※※】IBOutlet连出来的视图属性为什么可以被设置成weak"><a href="#【※※】IBOutlet连出来的视图属性为什么可以被设置成weak" class="headerlink" title="【※※】IBOutlet连出来的视图属性为什么可以被设置成weak?"></a>【※※】IBOutlet连出来的视图属性为什么可以被设置成weak?</h1><hr>
<p> 参考链接：<a href="http://stackoverflow.com/questions/7678469/should-iboutlets-be-strong-or-weak-under-arc" target="_blank" rel="external"> Should IBOutlets be strong or weak under ARC?</a></p>
<p> 文章告诉我们：</p>
<blockquote>
<p>因为既然有外链那么视图在xib或者storyboard中肯定存在，视图已经对它有一个强引用了。</p>
</blockquote>
<p> 不过这个回答漏了个重要知识，使用storyboard（xib不行）创建的vc，会有一个叫<code>_topLevelObjectsToKeepAliveFromStoryboard</code>的私有数组强引用所有top level的对象，所以这时即便outlet声明成weak也没关系</p>
<h1 id="【※※※※※】IB中User-Defined-Runtime-Attributes如何使用？"><a href="#【※※※※※】IB中User-Defined-Runtime-Attributes如何使用？" class="headerlink" title="【※※※※※】IB中User Defined Runtime Attributes如何使用？"></a>【※※※※※】IB中User Defined Runtime Attributes如何使用？</h1><hr>
<p> User Defined Runtime Attributes 是一个不被看重但功能非常强大的的特性，<br> 它能够通过KVC的方式配置一些你在interface builder 中不能配置的属性。当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的viewcontroller<br> <img src="http://img.blog.csdn.net/20160405135339547" alt="这里写图片描述"></p>
<h1 id="【※※※】如何调试BAD-ACCESS错误"><a href="#【※※※】如何调试BAD-ACCESS错误" class="headerlink" title="【※※※】如何调试BAD_ACCESS错误"></a>【※※※】如何调试BAD_ACCESS错误</h1><hr>
<ol>
<li>设置全局断点: <img src="http://img.blog.csdn.net/20160405140050909" alt="这里写图片描述"></li>
<li>开启僵尸模式 和 BAD_ACCESS检测模式(Xcode7.0以后)<img src="http://img.blog.csdn.net/20160405140108831" alt="这里写图片描述"></li>
</ol>
<h1 id="【※※※】lldb（gdb）常用的调试命令？"><a href="#【※※※】lldb（gdb）常用的调试命令？" class="headerlink" title="【※※※】lldb（gdb）常用的调试命令？"></a>【※※※】lldb（gdb）常用的调试命令？</h1><hr>
<ol>
<li>breakpoint 设置断点定位到某一个函数</li>
<li>n 断点指针下一步</li>
<li><p>po打印对象</p>
<p>更多 lldb（gdb） 调试命令可查看</p>
</li>
<li><p><a href="http://lldb.llvm.org/lldb-gdb.html" target="_blank" rel="external">The LLDB Debugger </a>；</p>
</li>
<li>苹果官方文档：<a href="https://developer.apple.com/library/ios/technotes/tn2239/_index.html" target="_blank" rel="external"> iOS Debugging Magic</a> 。<h1 id="protocol-和-category-中如何使用-property"><a href="#protocol-和-category-中如何使用-property" class="headerlink" title="@protocol 和 category 中如何使用 @property"></a>@protocol 和 category 中如何使用 @property</h1></li>
</ol>
<hr>
<p> 在protocol中使用property只会生成setter和getter方法声明,我们使用属性的目的,是希望遵守我协议的对象的实现该属性<br> category 使用 @property 也是只会生成setter和getter方法的声明,如果我们真的需要给category增加属性的实现,需要借助于运行时的两个函数<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objc_setAssociatedObject</div><div class="line">objc_getAssociatedObject</div></pre></td></tr></table></figure></p>
<p> 参考: </p>
<ol>
<li><a href="http://www.jianshu.com/p/4fea8fa60d75" target="_blank" rel="external">http://www.jianshu.com/p/4fea8fa60d75</a></li>
<li><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8B%EF%BC%89.md" target="_blank" rel="external">微博@iOS程序犭袁</a></li>
<li><p>原文链接: <a href="http://blog.csdn.net/zhz459880251/article/details/51106988" target="_blank" rel="external">http://blog.csdn.net/zhz459880251/article/details/51106988</a></p>
</li>
</ol>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="zhzDeveloper.github.io/2016/04/09/iOS-面试题整理/" data-id="cj3uwrxez000cc9hl7onoi9xq" class="article-share-link">分享</a><div class="tags"></div><div class="post-nav"><a href="/2016/04/26/忽略编译警告/" class="pre">忽略编译警告</a><a href="/2016/04/07/GCD小结/" class="next">GCD小结</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="zhzDeveloper.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS-分类/">iOS-分类</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios平台/">ios平台</a><span class="category-list-count">67</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios平台-UI控件/">ios平台,UI控件</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios平台-图片处理/">ios平台,图片处理</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios平台-开发工具/">ios平台,开发工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/swift/">swift</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发工具/">开发工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则/">正则</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机技巧/">计算机技巧</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/03/02/数据cache/">数据cache</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/13/Python 爬虫初探/">Python 爬虫初探</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/12/数组排序sortedArrayUsingComparator/">数组排序sortedArrayUsingComparator</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/macOS Sierra 找回消失的 “任何来源”/">macOS Sierra 找回消失的 “任何来源”</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/11/Method Swizzling(转载+补充)/">Method Swizzling(转载+补充)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/10/instancesRespondToSelector与respondsToSelector的区别/">instancesRespondToSelector与respondsToSelector的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/08/生成Description/">生成Description</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/26/忽略编译警告/">忽略编译警告</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/09/iOS-面试题整理/">iOS-面试题整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/07/GCD小结/">GCD小结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">zhz blogs.</a> Powered by<a rel="nofollow" target="_blank" href="https://github.com/zhzDeveloper"> zhz.</a><a rel="nofollow" target="_blank" href="http://zhzdeveloper.github.io/"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/zhzDeveloper"> zhz.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>